{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#sqlactive","title":"SQLActive","text":"<p>A sleek, powerful and asynchronous ActiveRecord-style wrapper for SQLAlchemy. Bring Django-like queries, automatic timestamps, nested eager loading, and dictionary serialization for SQLAlchemy models.</p> <p>Heavily inspired by sqlalchemy-mixins.</p> <p>The source code for this project is available on GitHub.</p> <ul> <li>SQLActive</li> <li>Features</li> <li>Installation</li> <li>Usage<ul> <li>1. Define the Models</li> <li>2. Initialize the Database</li> <li>3. Perform CRUD Operations</li> <li>4. Perform Bulk Operations</li> <li>5. Perform Queries</li> <li>6. Perform Native Queries</li> <li>7. Manage Timestamps</li> </ul> </li> <li>License</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Asynchronous Support: Async operations for better scalability.</li> <li>ActiveRecord-like methods: Perform CRUD operations with a syntax similar to   Peewee.</li> <li>Django-like queries: Perform intuitive and   expressive queries.</li> <li>Nested eager loading: Load nested relationships efficiently.</li> <li>Automatic timestamps: Auto-manage <code>created_at</code> and <code>updated_at</code> fields.</li> <li>Dictionary serialization: Convert models to JSON-friendly dictionaries with ease.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Use the package manager pip:</p> <pre><code>pip install sqlactive\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#1-define-the-models","title":"1. Define the Models","text":"<p>The <code>ActiveRecordBaseModel</code> class provides a base class for your models.</p> <p>It inherits from:</p> <ul> <li><code>ActiveRecordMixin</code>: Provides a set of ActiveRecord-like     helper methods for interacting with the database.</li> <li><code>TimestampMixin</code>: Adds the <code>created_at</code> and <code>updated_at</code> timestamp columns.</li> <li><code>SerializationMixin</code>: Provides serialization and deserialization methods.</li> </ul> <p>It is recommended to define a <code>BaseModel</code> class that inherits from <code>ActiveRecordBaseModel</code> and use it as the base class for all models as shown in the following example:</p> <pre><code>from sqlalchemy import String, ForeignKey\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\nfrom sqlactive import ActiveRecordBaseModel\n\n# Define the BaseModel class\nclass BaseModel(ActiveRecordBaseModel):\n    __abstract__ = True\n\n# Define the models\nclass User(BaseModel):\n    __tablename__ = 'users'\n\n    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True, index=True)\n    username: Mapped[str] = mapped_column(String(18), nullable=False, unique=True)\n    name: Mapped[str] = mapped_column(String(50), nullable=False)\n    age: Mapped[int] = mapped_column(nullable=False)\n\n    posts: Mapped[list['Post']] = relationship(back_populates='user')\n    comments: Mapped[list['Comment']] = relationship(back_populates='user')\n\nclass Post(BaseModel):\n    __tablename__ = 'posts'\n\n    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True, index=True)\n    title: Mapped[str] = mapped_column(String(100), nullable=False)\n    body: Mapped[str] = mapped_column(nullable=False)\n    rating: Mapped[int] = mapped_column(nullable=False)\n    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'))\n\n    user: Mapped['User'] = relationship(back_populates='posts')\n    comments: Mapped[list['Comment']] = relationship(back_populates='post')\n\n\nclass Comment(BaseModel):\n    __tablename__ = 'comments'\n\n    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True, index=True)\n    body: Mapped[str] = mapped_column(nullable=False)\n    post_id: Mapped[int] = mapped_column(ForeignKey('posts.id'))\n    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'))\n\n    post: Mapped['Post'] = relationship(back_populates='comments')\n    user: Mapped['User'] = relationship(back_populates='comments')\n</code></pre> <p>Warning</p> <p>When defining a <code>BaseModel</code> class, don't forget to set <code>__abstract__</code> to <code>True</code> in the base class to avoid creating tables for the base class.</p> <p>Note</p> <p>The models can directly inherit from the <code>ActiveRecordBaseModel</code> class:</p> <pre><code>from sqlactive import ActiveRecordBaseModel\nclass User(ActiveRecordBaseModel):\n    __tablename__ = 'users'\n    # ...\n</code></pre> <p>However, it is recommended to create a base class for your models and inherit from it.</p> <p>Tip</p> <p>Your <code>BaseModel</code> class can also inherit directly from the mixins. For example, if you don't want to implement automatic timestamps don't inherit from <code>ActiveRecordBaseModel</code> class. Instead, inherit from <code>ActiveRecordMixin</code> and/or <code>SerializationMixin</code>:</p> <pre><code>from sqlactive import ActiveRecordMixin, SerializationMixin\nclass BaseModel(ActiveRecordMixin, SerializationMixin):\n    __abstract__ = True\n</code></pre>"},{"location":"#2-initialize-the-database","title":"2. Initialize the Database","text":"<pre><code>from asyncio import current_task\nfrom sqlalchemy.ext.asyncio import (\n    create_async_engine,\n    async_sessionmaker,\n    async_scoped_session,\n)\nfrom sqlactive import ActiveRecordBaseModel\n\n# Connect to the database\nDATABASE_URL = 'sqlite+aiosqlite://'\nasync_engine = create_async_engine(DATABASE_URL, echo=False)\nasync_sessionmaker = async_sessionmaker(\n    bind=async_engine,\n    expire_on_commit=False,\n)\nasync_scoped_session = async_scoped_session(\n    async_sessionmaker,\n    scopefunc=current_task,\n)\n\n# Set the session\nBaseModel.set_session(async_scoped_session)\n\n# Initialize the tables\nasync with async_engine.begin() as conn:\n    await conn.run_sync(BaseModel.metadata.create_all)\n</code></pre> <p>The use of the <code>expire_on_commit</code> flag is explained in the warning of this section.</p> <p>Tip</p> <p>Use the <code>DBConnection</code> class as a shortcut to initialize the database. The <code>DBConnection</code> class is a wrapper around the <code>async_engine</code>, <code>async_sessionmaker</code> and <code>async_scoped_session</code> objects:</p> <pre><code>from sqlactive import DBConnection\n\nDATABASE_URL = 'sqlite+aiosqlite://'\nconn = DBConnection(DATABASE_URL, echo=False)\nawait conn.init_db(BaseModel)\n</code></pre> <p>See the DB Connection Helper section for more information.</p>"},{"location":"#3-perform-crud-operations","title":"3. Perform CRUD Operations","text":"<pre><code>user = await User.create(username='John1234', name='John Doe', age=25)\nprint(user)\n# &lt;User #1&gt;\n\nuser.name = 'Johnny Doe'\nuser.age = 30\nawait user.save()\nprint(user.name)\n# Johnny Doe\n\nuser = await User.get(1)\nprint(user)\n# &lt;User #1&gt;\n\nawait user.update(name='John Doe', age=20)\nprint(user.age)\n# 20\n\nawait user.delete()\n</code></pre> <p>Danger</p> <p>The <code>delete</code> and <code>remove</code> methods are not soft deletes. Both of them permanently delete the row from the database. So, if you want to keep the row in the database, implement a custom delete method and use <code>save</code> method instead (i.e. a <code>is_deleted</code> column).</p> <p>Tip</p> <p>Check the <code>ActiveRecordMixin</code> API Reference class to see all the available methods.</p>"},{"location":"#4-perform-bulk-operations","title":"4. Perform Bulk Operations","text":"<pre><code>users = [\n    User(username='John1234', name='John Doe', age=20),\n    User(username='Jane1234', name='Jane Doe', age=21),\n    User(username='Bob1234', name='Bob Doe', age=22),\n]\n\nawait User.create_all(users, refresh=True)\nusers = await User.find(username__endswith='Doe').all()\nprint(users)\n# [&lt;User #1&gt;, &lt;User #2&gt;]\n\nawait User.delete_all(users)\n\nusers = await User.find(username__endswith='Doe').all()\nprint(users)\n# []\n</code></pre> <p>Warning</p> <p>When calling bulk operation methods, i.e. <code>save_all</code>, <code>create_all</code>, <code>update_all</code> and <code>delete_all</code>, the <code>refresh</code> flag must be set to <code>True</code> in order to access the updated attributes of the affected rows. NOTE: This may lead to a higher latency due to additional database queries.</p> <pre><code>users = [\n    User(username='John1234', name='John Doe', age=20),\n    User(username='Jane1234', name='Jane Doe', age=21),\n    # ...,\n]\nawait User.save_all(users, refresh=True)\nprint(users[0].updated_at)\n# 2024-12-28 23:00:51\n</code></pre> <p>If <code>refresh</code> is not set to <code>True</code>, a <code>sqlalchemy.orm.exc.DetachedInstanceError</code> may be raised when trying to access the updated attributes because the instances are detached (unavailable after commit).</p> <pre><code>users = [\n    User(username='John1234', name='John Doe', age=20),\n    User(username='Jane1234', name='Jane Doe', age=21),\n    # ...,\n]\nawait User.save_all(users)\nprint(users[0].updated_at)\n# Traceback (most recent call last):\n#     ...\n# sqlalchemy.orm.exc.DetachedInstanceError: Instance &lt;User ...&gt; is not bound\n# to a Session; attribute refresh operation cannot proceed\n# (Background on this error at: https://sqlalche.me/e/20/bhk3)\n</code></pre> <p>Another option is to set the <code>expire_on_commit</code> flag to <code>False</code> in the <code>async_sessionmaker</code> when initializing the database. However, this does not update the instances after commit. It just keeps the instances available after commit.</p> <pre><code>async_sessionmaker = async_sessionmaker(\n    bind=async_engine,\n    expire_on_commit=False,\n)\n</code></pre> <p>Tip</p> <p>Check the <code>ActiveRecordMixin</code> API Reference class to see all the available methods.</p>"},{"location":"#5-perform-queries","title":"5. Perform Queries","text":"<p>Perform simple and complex queries, eager loading, and dictionary serialization:</p> <pre><code>from sqlactive import JOINED, SUBQUERY\n\nuser = await User.filter(name='John Doe').first()\nprint(user)\n# &lt;User #1&gt;\n\nposts = await Post.filter(rating__in=[2, 3, 4], user___name__like='%Bi%').all()\nprint(posts)\n# [&lt;Post #1&gt;, &lt;Post #2&gt;, &lt;Post #3&gt;]\n\nposts = await Post.sort('-rating', 'user___name').all()\nprint(posts)\n# [&lt;Post #3&gt;, &lt;Post #1&gt;, &lt;Post #2&gt;, &lt;Post #4&gt;, ...]\n\ncomments = await Comment.join(Comment.user, Comment.post).unique_all()\nprint(comments)\n# [&lt;Comment 1&gt;, &lt;Comment 2&gt;, &lt;Comment 3&gt;, &lt;Comment 4&gt;, &lt;Comment 5&gt;, ...]\n\nuser = await User.with_subquery(User.posts).first()\nprint(user)\n# &lt;User #1&gt;\nprint(user.posts)\n# [&lt;Post #1&gt;, &lt;Post #2&gt;, &lt;Post #3&gt;]\n\nschema = {\n    User.posts: JOINED,\n    User.comments: (SUBQUERY, {\n        Comment.post: SELECT_IN\n    }),\n}\nuser = await User.with_schema(schema).unique_first()\nprint(user.comments[0].post.title)\n# Lorem ipsum\n\nuser_dict = user.to_dict(nested=True)\nprint(user_dict)\n# {'id': 1, 'username': 'John1234', 'name': 'John Doe', ...}\n</code></pre> <p>For more flexibility, the low-level <code>filter_expr</code> method can be used:</p> <pre><code>Post.filter(*Post.filter_expr(rating__gt=2, body='text'))\n# or\nsession.query(Post).filter(*Post.filter_expr(rating__gt=2, body='text'))\n</code></pre> <p>It's like filter_by in SQLALchemy, but also allows magic operators like <code>rating__gt</code>.</p> <p>See the low-level SmartQueryMixin methods for more details.</p> <p>Note</p> <p><code>filter_expr</code> method is very low-level and does NOT do magic Django-like joins. Use <code>smart_query</code> for that:</p> <pre><code>query = User.smart_query(\n    criterion=(or_(User.age == 30, User.age == 32),),\n    filters={'username__like': '%8'},\n    sort_columns=(User.username,),\n    sort_attrs=('age',),\n    schema={\n        User.posts: JOINED,\n        User.comments: (SUBQUERY, {\n            Comment.post: SELECT_IN\n        }),\n    },\n)\nusers = await query.unique_all()\nprint(users)\n# [&lt;User #1&gt;, &lt;User #3&gt;]\n</code></pre> <p>Tip</p> <p>Check the <code>ActiveRecordMixin</code> API Reference class to see all the available methods.</p>"},{"location":"#6-perform-native-queries","title":"6. Perform Native Queries","text":"<p>Perform native SQLAlchemy queries using the <code>execute</code> method:</p> <pre><code>    from sqlalchemy import select, func\n    from sqlactive import execute\n\n    query = select(User.age, func.count(User.id)).group_by(User.age)\n    result = await execute(query)\n    # [(20, 1), (22, 4), (25, 12)]\n</code></pre> <p>If your base model is not <code>ActiveRecordBaseModel</code> you must pass your base model class to the <code>base_model</code> argument of the <code>execute</code> method:</p> <pre><code>    from sqlalchemy import select, func\n    from sqlactive import ActiveRecordBaseModel, execute\n\n    # Note that it does not matter if your base model\n    # inherits from `ActiveRecordBaseModel`, you still\n    # need to pass it to this method\n    class BaseModel(ActiveRecordBaseModel):\n        __abstract__ = True\n\n    class User(BaseModel):\n        __tablename__ = 'users'\n        # ...\n\n    query = select(User.age, func.count(User.id)).group_by(User.age)\n    result = await execute(query, BaseModel)\n    # [(20, 1), (22, 4), (25, 12)]\n</code></pre>"},{"location":"#7-manage-timestamps","title":"7. Manage Timestamps","text":"<p>Timestamps (<code>created_at</code> and <code>updated_at</code>) are automatically managed:</p> <pre><code>user = await User.create(username='John1234', name='John Doe', age=25)\nprint(user.created_at)\n# 2024-12-28 23:00:51\nprint(user.updated_at)\n# 2024-12-28 23:00:51\n\nawait asyncio.sleep(1)\n\nawait user.update(name='Johnny Doe')\nprint(user.updated_at)\n# 2024-12-28 23:00:52\n</code></pre> <p>Tip</p> <p>Check the <code>TimestampMixin</code> class to know how to customize the timestamps behavior.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT License.</p>"},{"location":"contributing/","title":"Contributing Guidelines","text":"<p>Thank you for your interest in contributing to SQLActive! Please take a moment to review this document before submitting a pull request.</p> <p>Table of Contents</p> <ul> <li>Contributing Guidelines</li> <li>Why should you read these guidelines?</li> <li>Ground Rules<ul> <li>Responsibilities</li> <li>Tools and Workflow</li> </ul> </li> <li>Your First Pull Request<ul> <li>Getting Started</li> <li>Setup Instructions</li> </ul> </li> <li>Reporting Issues<ul> <li>Security Issues</li> <li>Filing a Bug Report</li> </ul> </li> <li>Suggesting Features or Enhancements</li> <li>Code Conventions<ul> <li>Code Style</li> <li>Commit Message Format</li> <li>Pull Request Checklist</li> </ul> </li> <li>Thank You!</li> </ul>"},{"location":"contributing/#why-should-you-read-these-guidelines","title":"Why should you read these guidelines?","text":"<p>Following these guidelines ensures that your contributions align with the project's standards, respect the time of maintainers, and facilitate a smooth collaboration process.</p>"},{"location":"contributing/#ground-rules","title":"Ground Rules","text":""},{"location":"contributing/#responsibilities","title":"Responsibilities","text":"<ul> <li>Ensure cross-platform compatibility for all changes (Windows, macOS,   Debian, and Ubuntu Linux).</li> <li>Follow the PEP 8 style   guide and use single quotes (<code>'</code>) for strings.</li> <li>Adhere to clean code principles, such as SOLID, DRY, and   KISS. Avoid unnecessary complexity.</li> <li>Use Active Record patterns for database interactions where applicable.</li> <li>Limit the use of classes unless strictly necessary; prefer functions when   simpler and sufficient.</li> <li>Keep contributions small and focused. One feature or fix per pull request.</li> <li>Discuss significant changes or enhancements transparently by opening an   issue first.</li> <li>Be respectful and welcoming. Follow the   Python Community Code of Conduct.</li> </ul>"},{"location":"contributing/#tools-and-workflow","title":"Tools and Workflow","text":"<ul> <li>Use Ruff as the linter and formatter (Black could be an alternative).</li> <li>Write NumPy-style docstrings for all public functions, classes, attributes,   and properties.</li> <li>Commit messages and pull requests must follow specific prefixes:<ul> <li><code>ci:</code> for CI/CD changes.</li> <li><code>test:</code> Update tests/* files.</li> <li><code>dist:</code> Changes to dependencies, e.g. <code>requirements.txt</code>.</li> <li><code>minor:</code> Small changes.</li> <li><code>docs:</code> Updates to documentation. <code>doc</code> is also a valid prefix.</li> <li><code>fix:</code> Bug fixes.</li> <li><code>refactor:</code> Refactor of existing code.</li> <li><code>nit:</code> Small code review changes mainly around style or syntax.</li> <li><code>feat:</code> New features.</li> </ul> </li> </ul>"},{"location":"contributing/#your-first-pull-request","title":"Your First Pull Request","text":""},{"location":"contributing/#getting-started","title":"Getting Started","text":"<p>If this is your first pull request:</p> <ul> <li>Watch the How to Contribute to an Open Source Project on GitHub   video series.</li> <li>Search for existing discussions to ensure your contribution doesn't duplicate   ongoing efforts.</li> </ul>"},{"location":"contributing/#setup-instructions","title":"Setup Instructions","text":"<ol> <li>Fork the repository.</li> <li>Clone your fork to your local machine.</li> <li>Set up a virtual environment:     <pre><code>python -m venv venv\nsource venv/bin/activate  # on Windows: venv\\Scripts\\activate\n</code></pre></li> <li>Install dependencies:     <pre><code>pip install -r requirements.txt\n</code></pre></li> <li>Install <code>ruff</code>:     <pre><code>pip install ruff\n</code></pre></li> <li>Run tests and <code>Ruff</code> linter formatter to confirm the setup:     <pre><code>python -m unittest discover -s tests -t .\npython -m ruff check .\n</code></pre></li> </ol>"},{"location":"contributing/#reporting-issues","title":"Reporting Issues","text":""},{"location":"contributing/#security-issues","title":"Security Issues","text":"<p>For security vulnerabilities, do not open an issue. Instead, email dairoandres123@gmail.com.</p> <p>In order to determine whether you are dealing with a security issue, ask yourself these two questions:</p> <ul> <li>Can I access something that's not mine, or something I shouldn't have   access to?</li> <li>Can I disable something for other people?</li> </ul> <p>If the answer to either of those two questions are \"yes\", then you're probably dealing with a security issue. Note that even if you answer \"no\" to both questions, you may still be dealing with a security issue, so if you're unsure, just email dairoandres123@gmail.com.</p>"},{"location":"contributing/#filing-a-bug-report","title":"Filing a Bug Report","text":"<p>When reporting a bug, please include:</p> <ol> <li>Python version.</li> <li>Operating system and architecture.</li> <li>Steps to reproduce the issue.</li> <li>Expected behavior.</li> <li>Actual behavior, including error messages and stack traces.</li> </ol> <p>General questions should go to the python-discuss mailing list instead of the issue tracker. The Pythonists there will answer or ask you to file an issue if you have tripped over a bug.</p>"},{"location":"contributing/#suggesting-features-or-enhancements","title":"Suggesting Features or Enhancements","text":"<p>To suggest a feature:</p> <ol> <li>Open an issue on the GitHub issues page.</li> <li>Clearly describe the desired feature, its purpose, and its expected behavior.</li> <li>If possible, include examples or PseudoCode.</li> </ol>"},{"location":"contributing/#code-conventions","title":"Code Conventions","text":""},{"location":"contributing/#code-style","title":"Code Style","text":"<ul> <li>Follow PEP 8 guidelines, enforced by Ruff and Black.</li> <li>Use single quotes (<code>'</code>) for strings unless escaping becomes cumbersome.</li> <li>Write docstrings in NumPy style. Example:     <pre><code>def add(a: int, b: int) -&gt; int:\n    \"\"\"\n    Add two integers.\n\n    Parameters\n    ----------\n    a : int\n        First integer.\n    b : int\n        Second integer.\n\n    Returns\n    -------\n    int\n        Sum of the integers.\n    \"\"\"\n\n    return a + b\n</code></pre></li> </ul>"},{"location":"contributing/#commit-message-format","title":"Commit Message Format","text":"<ul> <li>Use a prefix to categorize your commit:<ul> <li><code>ci:</code> for CI/CD changes.</li> <li><code>test:</code> Update tests/* files.</li> <li><code>dist:</code> Changes to dependencies, e.g. <code>requirements.txt</code>.</li> <li><code>minor:</code> Small changes.</li> <li><code>docs:</code> Updates to documentation. <code>doc</code> is also a valid prefix.</li> <li><code>fix:</code> Bug fixes.</li> <li><code>refactor:</code> Refactor of existing code.</li> <li><code>nit:</code> Small code review changes mainly around style or syntax.</li> <li><code>feat:</code> New features.</li> </ul> </li> <li>Example:     <pre><code>feat: add support for PostgreSQL database connections\n</code></pre></li> </ul>"},{"location":"contributing/#pull-request-checklist","title":"Pull Request Checklist","text":"<p>Before submitting a pull request:</p> <ol> <li>Add or update tests for your changes.</li> <li>Ensure all tests pass:     <pre><code>python -m unittest discover -s tests -t .\n</code></pre></li> <li>Check code linting:     <pre><code>python -m ruff check .\n</code></pre></li> <li>Update the documentation, if necessary.</li> <li>Provide a clear and descriptive pull request title and description.</li> </ol> <p>Pull requests titles should be short and descriptive, and should not exceed 72 characters. Also, must follow the specified commit message format.</p>"},{"location":"contributing/#thank-you","title":"Thank You!","text":"<p>Your contributions help make SQLActive better for everyone. Thank you for taking the time to improve the project!</p>"},{"location":"pages/db_connection_helper/","title":"DB Connection Helper","text":"<p>The <code>DBConnection</code> class provides functions for connecting to a database and initializing tables.</p>"},{"location":"pages/db_connection_helper/#usage","title":"Usage","text":"<pre><code>from sqlactive import DBConnection\n\nDATABASE_URL = 'sqlite+aiosqlite://'\n\ndb = DBConnection(DATABASE_URL, echo=False)\n</code></pre> <p>This is a shortcut:</p> <pre><code>DATABASE_URL = 'sqlite+aiosqlite://'\nasync_engine = create_async_engine(DATABASE_URL, echo=False)\nasync_sessionmaker = async_sessionmaker(bind=async_engine, expire_on_commit=False)\nasync_scoped_session = async_scoped_session(async_sessionmaker, scopefunc=current_task)\n</code></pre> <p>Note that the keyword arguments of the <code>DBConnection</code> class are passed to the <code>sqlalchemy.ext.asyncio.create_async_engine</code> function.</p>"},{"location":"pages/db_connection_helper/#methods","title":"Methods","text":"<p>The <code>DBConnection</code> class has the following methods:</p> <ul> <li><code>init_db()</code>: Initialize the database tables.</li> <li><code>close()</code>: Close the database connection.</li> </ul>"},{"location":"pages/db_connection_helper/#init_db","title":"init_db","text":"<p>Initialize the database tables. It also sets the <code>session</code> attribute of the base model to the <code>async_scoped_session</code> async session factory:</p> <pre><code>from sqlactive import DBConnection\n\nDATABASE_URL = 'sqlite+aiosqlite://'\nconn = DBConnection(DATABASE_URL, echo=True)\nasyncio.run(conn.init_db()) # Initialize the database\n</code></pre> <p>If your base model is not <code>ActiveRecordBaseModel</code> you must pass your base model class to this method in the <code>base_model</code> argument:</p> <pre><code>from sqlactive import DBConnection, ActiveRecordBaseModel\n\n# Note that it does not matter if your base model\n# inherits from `ActiveRecordBaseModel`, you still\n# need to pass it to this method\nclass BaseModel(ActiveRecordBaseModel):\n    __abstract__ = True\n\nDATABASE_URL = 'sqlite+aiosqlite://'\nconn = DBConnection(DATABASE_URL, echo=True)\nasyncio.run(conn.init_db(BaseModel)) # Pass your base model\n</code></pre>"},{"location":"pages/db_connection_helper/#close","title":"close","text":"<p>Close the database connection. It also sets the <code>session</code> attribute of the base model to <code>None</code>:</p> <pre><code>from sqlactive import DBConnection\n\nDATABASE_URL = 'sqlite+aiosqlite://'\nconn = DBConnection(DATABASE_URL, echo=True)\nasyncio.run(conn.init_db())\n\n# Perform operations...\n\nasyncio.run(conn.close()) # Close the database connection\n</code></pre> <p>If your base model is not <code>ActiveRecordBaseModel</code> you should pass your base model cl0ass to this method in the <code>base_model</code> argument:</p> <pre><code>from sqlactive import DBConnection, ActiveRecordBaseModel\n\n# Note that it does not matter if your base model\n# inherits from `ActiveRecordBaseModel`, you still\n# need to pass it to this method\nclass BaseModel(ActiveRecordBaseModel):\n    __abstract__ = True\n\nDATABASE_URL = 'sqlite+aiosqlite://'\nconn = DBConnection(DATABASE_URL, echo=True)\nasyncio.run(conn.init_db())\n\n# Perform operations...\n\nasyncio.run(conn.close(BaseModel)) # Pass your base model\n</code></pre>"},{"location":"pages/execute/","title":"Native SQLAlchemy queries","text":"<p>You can execute native SQLAlchemy queries using the <code>sqlactive.conn.execute</code> function.</p>"},{"location":"pages/execute/#usage","title":"Usage","text":"<pre><code>    from sqlalchemy import select, func\n    from sqlactive import execute\n\n    query = select(User.age, func.count(User.id)).group_by(User.age)\n    result = await execute(query)\n</code></pre> <p>If your base model is not <code>ActiveRecordBaseModel</code> you must pass your base model class to the <code>base_model</code> argument of the <code>execute</code> method:</p> <pre><code>    from sqlalchemy import select, func\n    from sqlactive import ActiveRecordBaseModel, execute\n\n    # Note that it does not matter if your base model\n    # inherits from `ActiveRecordBaseModel`, you still\n    # need to pass it to this method\n    class BaseModel(ActiveRecordBaseModel):\n        __abstract__ = True\n\n    class User(BaseModel):\n        __tablename__ = 'users'\n        # ...\n\n    query = select(User.age, func.count(User.id)).group_by(User.age)\n    result = await execute(query, BaseModel) # or execute(query, User)\n</code></pre> <p>Warning</p> <p>Your base model must have a session in order to use this method. Otherwise, it will raise an <code>NoSessionError</code> exception.</p>"},{"location":"pages/inspection_mixin/","title":"InspectionMixin","text":"<p>The <code>InspectionMixin</code> class provides attributes and properties inspection functionality for SQLAlchemy models.</p> <p>Info</p> <p>This mixin is intended to extend the functionality of the <code>SmartQueryMixin</code> and <code>SerializationMixin</code>. It is not intended to be used on its own.</p> <p>Table of Contents</p> <ul> <li>InspectionMixin</li> <li>Instance Methods<ul> <li>repr</li> </ul> </li> <li>Class Methods<ul> <li>get_class_of_relation</li> </ul> </li> <li>Properties<ul> <li>id_str</li> <li>columns</li> <li>primary_keys_full</li> <li>primary_keys</li> <li>relations</li> <li>settable_relations</li> <li>hybrid_properties</li> <li>hybrid_methods_full</li> <li>hybrid_methods</li> <li>filterable_attributes</li> <li>sortable_attributes</li> <li>settable_attributes</li> </ul> </li> </ul>"},{"location":"pages/inspection_mixin/#instance-methods","title":"Instance Methods","text":""},{"location":"pages/inspection_mixin/#repr","title":"repr","text":"<pre><code>def __repr__(self)\n</code></pre> <p>Print the model in a readable format including the primary key.</p> <p>Format: <pre><code>   &lt;ClassName #PrimaryKey&gt;\n</code></pre></p> <p>Example:</p> <pre><code>user = await User.get(id=1)\nprint(user)\n# User #1\nusers = await User.find(username__endswith='Doe').all()\nprint(users)\n# [&lt;User #1&gt;, &lt;User #2&gt;]\n</code></pre>"},{"location":"pages/inspection_mixin/#class-methods","title":"Class Methods","text":""},{"location":"pages/inspection_mixin/#get_class_of_relation","title":"get_class_of_relation","text":"<pre><code>def get_class_of_relation(relation_name: str)\n</code></pre> <p>Gets the class of a relationship by its name.</p> <p>Parameters:</p> <ul> <li><code>relation_name</code>: The name of the relationship.</li> </ul> <p>Returns:</p> <ul> <li><code>type</code>: The class of the relationship.</li> </ul> <p>Example:</p> <pre><code>user = await User.get(id=1)\nuser.get_class_of_relation('posts')\n# &lt;class 'Post'&gt;\n</code></pre>"},{"location":"pages/inspection_mixin/#properties","title":"Properties","text":""},{"location":"pages/inspection_mixin/#id_str","title":"id_str","text":"<p>Returns primary key as string.</p> <p>If there is a composite primary key, returns a hyphenated string, as follows: <code>'1-2-3'</code>.</p> <p>If there is no primary key, returns <code>'None'</code>.</p> <pre><code>bob = User.create(name='Bob')\nprint(bob.id_str)\n# 1\n</code></pre>"},{"location":"pages/inspection_mixin/#columns","title":"columns","text":"<p>Sequence of string key names for all columns in this collection.</p> <pre><code>print(User.columns)\n# ['id', 'username', 'name', 'age', 'created_at', 'updated_at']\n</code></pre>"},{"location":"pages/inspection_mixin/#primary_keys_full","title":"primary_keys_full","text":"<p>Gets primary key properties for a SQLAlchemy cls.</p> <p>Taken from marshmallow_sqlalchemy.</p> <pre><code>print(User.primary_keys_full)\n# [&lt;sqlalchemy.orm.attributes.InstrumentedAttribute 'id'&gt;]\n</code></pre>"},{"location":"pages/inspection_mixin/#primary_keys","title":"primary_keys","text":"<p>Returns a <code>list</code> of primary key names.</p> <pre><code>print(User.primary_keys)\n# ['id']\n</code></pre>"},{"location":"pages/inspection_mixin/#relations","title":"relations","text":"<p>Returns a <code>list</code> of relationship names.</p> <pre><code>print(User.relations)\n# ['posts', 'comments']\n</code></pre>"},{"location":"pages/inspection_mixin/#settable_relations","title":"settable_relations","text":"<p>Returns a <code>list</code> of settable relationship names.</p> <pre><code>print(User.settable_relations)\n# ['posts', 'comments']\n</code></pre>"},{"location":"pages/inspection_mixin/#hybrid_properties","title":"hybrid_properties","text":"<p>Returns a <code>list</code> of hybrid property names.</p> <pre><code>print(User.hybrid_properties)\n# ['is_adult']\n</code></pre>"},{"location":"pages/inspection_mixin/#hybrid_methods_full","title":"hybrid_methods_full","text":"<p>Returns a <code>dict</code> of hybrid methods.</p> <pre><code>print(User.hybrid_methods_full)\n# {'is_adult': &lt;sqlalchemy.orm.attributes.InstrumentedAttribute 'is_adult'&gt;}\n</code></pre>"},{"location":"pages/inspection_mixin/#hybrid_methods","title":"hybrid_methods","text":"<p>Returns a <code>list</code> of hybrid method names.</p> <pre><code>print(User.hybrid_methods)\n# ['is_adult']\n</code></pre>"},{"location":"pages/inspection_mixin/#filterable_attributes","title":"filterable_attributes","text":"<p>Returns a <code>list</code> of filterable attributes.</p> <p>These are all columns, relations and hybrid properties.</p> <pre><code>print(User.filterable_attributes)\n# ['id', 'username', 'name', 'age', 'created_at', 'updated_at', 'posts', 'comments', 'is_adult']\n</code></pre>"},{"location":"pages/inspection_mixin/#sortable_attributes","title":"sortable_attributes","text":"<p>Returns a <code>list</code> of sortable attributes.</p> <p>These are all columns and hybrid properties.</p> <pre><code>print(User.sortable_attributes)\n# ['id', 'username', 'name', 'age', 'created_at', 'updated_at', 'is_adult']\n</code></pre>"},{"location":"pages/inspection_mixin/#settable_attributes","title":"settable_attributes","text":"<p>Returns a <code>list</code> of settable attributes.</p> <p>These are all columns, settable relations and hybrid properties.</p> <pre><code>print(User.settable_attributes)\n# ['id', 'username', 'name', 'age', 'created_at', 'updated_at', 'posts', 'comments', 'is_adult']\n</code></pre>"},{"location":"pages/serialization_mixin/","title":"SerializationMixin","text":"<p>The <code>SerializationMixin</code> class provides methods for serializing and deserializing SQLAlchemy models.</p> <p>It uses the <code>InspectionMixin</code> class functionality.</p> <p>Table of Contents</p> <ul> <li>SerializationMixin</li> <li>Serialization<ul> <li>to_dict</li> <li>to_json</li> </ul> </li> <li>Deserialization<ul> <li>from_dict</li> <li>from_json</li> </ul> </li> </ul>"},{"location":"pages/serialization_mixin/#serialization","title":"Serialization","text":""},{"location":"pages/serialization_mixin/#to_dict","title":"to_dict","text":"<pre><code>def to_dict(\n    nested: bool = False,\n    hybrid_attributes: bool = False,\n    exclude: list[str] | None = None,\n    nested_exclude: list[str] | None = None,\n)\n</code></pre> <p>Serializes the model to a dictionary.</p> <p>Parameters:</p> <ul> <li><code>nested</code>: Set to <code>True</code> to include nested relationships' data, by default False.</li> <li><code>hybrid_attributes</code>: Set to <code>True</code> to include hybrid attributes, by default False.</li> <li><code>exclude</code>: Exclude specific attributes from the result, by default None.</li> </ul> <p>Returns:</p> <ul> <li><code>dict[str, Any]</code>: Serialized model.</li> </ul> <p>Example:</p> <pre><code>user = await User.get(id=1)\nuser.to_dict()\n# {'id': 1, 'username': 'user1', 'name': 'John', 'age': 30, ...}\nuser.to_dict(nested=True)\n# {'id': 1, 'username': 'user1', 'name': 'John', 'age': 30, 'posts': [...], ...}\nuser.to_dict(hybrid_attributes=True)\n# {'id': 1, 'username': 'user1', 'name': 'John', 'age': 30, 'posts_count': 3, ...}\nuser.to_dict(exclude=['id', 'username'])\n# {'name': 'John', 'age': 30, ...}\n</code></pre>"},{"location":"pages/serialization_mixin/#to_json","title":"to_json","text":"<pre><code>def to_json(\n    nested: bool = False,\n    hybrid_attributes: bool = False,\n    exclude: list[str] | None = None,\n    nested_exclude: list[str] | None = None,\n    ensure_ascii: bool = False,\n    indent: int | str | None = None,\n    sort_keys: bool = False\n)\n</code></pre> <p>Serializes the model to JSON.</p> <p>Calls the <code>Self.to_dict</code> method and dumps it with <code>json.dumps</code>.</p> <p>Parameters:</p> <ul> <li><code>nested</code>: Set to <code>True</code> to include nested relationships' data, by default False.</li> <li><code>hybrid_attributes</code>: Set to <code>True</code> to include hybrid attributes, by default False.</li> <li><code>exclude</code>: Exclude specific attributes from the result, by default None.</li> <li><code>ensure_ascii</code>: If False, then the return value can contain non-ASCII characters if they appear in strings contained in obj. Otherwise, all such characters are escaped in JSON strings, by default False.</li> <li><code>indent</code>: If indent is a non-negative integer, then JSON array elements and object members will be pretty-printed with that indent level. An indent level of 0 will only insert newlines. <code>None</code> is the most compact representation, by default None.</li> <li><code>sort_keys</code>: Sort dictionary keys, by default False.</li> </ul> <p>Returns:</p> <ul> <li><code>str</code>: Serialized model.</li> </ul> <p>Example:</p> <pre><code>user = await User.get(id=1)\nuser.to_json()\n# {\"id\": 1, \"username\": \"user1\", \"name\": \"John\", \"age\": 30, ...}\nuser.to_json(nested=True)\n# {\"id\": 1, \"username\": \"user1\", \"name\": \"John\", \"age\": 30, \"posts\": [...], ...}\nuser.to_json(hybrid_attributes=True)\n# {\"id\": 1, \"username\": \"user1\", \"name\": \"John\", \"age\": 30, \"posts_count\": 3, ...}\nuser.to_json(exclude=['id', 'username'])\n# {\"name\": \"John\", \"age\": 30, ...}\n</code></pre>"},{"location":"pages/serialization_mixin/#deserialization","title":"Deserialization","text":""},{"location":"pages/serialization_mixin/#from_dict","title":"from_dict","text":"<pre><code>def from_dict(\n    data: dict[str, Any] | list[dict[str, Any]],\n    exclude: list[str] | None = None,\n    nested_exclude: list[str] | None = None\n)\n</code></pre> <p>Deserializes a dictionary to the model.</p> <p>Sets the attributes of the model with the values of the dictionary.</p> <p>Parameters:</p> <ul> <li><code>data</code>: Data to deserialize.</li> <li><code>exclude</code>: Exclude specific keys from the dictionary, by default None.</li> </ul> <p>Returns:</p> <ul> <li><code>Self | list[Self]</code>: Deserialized model or models.</li> </ul> <p>Raises:</p> <ul> <li><code>TypeError</code>: If the data is not a dictionary or list of dictionaries.</li> <li><code>KeyError</code>: If attribute doesn't exist.</li> </ul> <p>Example:</p> <pre><code>user = await User.from_dict({'name': 'John', 'age': 30})\nuser.to_dict()\n# {'name': 'John', 'age': 30, ...}\nusers = await User.from_dict([{'name': 'John', 'age': 30}, {'name': 'Jane', 'age': 25}])\nusers[0].to_dict()\n# {'name': 'John', 'age': 30, ...}\nusers[1].to_dict()\n# {'name': 'Jane', 'age': 25, ...}\n</code></pre>"},{"location":"pages/serialization_mixin/#from_json","title":"from_json","text":"<pre><code>def from_json(\n    json_string: str,\n    exclude: list[str] | None = None,\n    nested_exclude: list[str] | None = None\n)\n</code></pre> <p>Deserializes a JSON string to the model.</p> <p>Calls the <code>json.loads</code> method and sets the attributes of the model with the values of the JSON object using the <code>from_dict</code> method.</p> <p>Parameters:</p> <ul> <li><code>json_string</code>: JSON string.</li> <li><code>exclude</code>: Exclude specific keys from the dictionary, by default None.</li> </ul> <p>Returns:</p> <ul> <li><code>Self | list[Self]</code>: Deserialized model or models.</li> </ul> <p>Example:</p> <pre><code>user = await User.from_json('{\"name\": \"John\", \"age\": 30}')\nuser.to_dict()\n# {'name': 'John', 'age': 30, ...}\nusers = await User.from_json('[{\"name\": \"John\", \"age\": 30}, {\"name\": \"Jane\", \"age\": 25}]')\nusers[0].to_dict()\n# {'name': 'John', 'age': 30, ...}\nusers[1].to_dict()\n# {'name': 'Jane', 'age': 25, ...}\n</code></pre>"},{"location":"pages/smart_query_mixin/","title":"SmartQueryMixin","text":"<p>The <code>SmartQueryMixin</code> class provides advanced query functionality for SQLAlchemy models, allowing you to filter, sort, and eager load data in a single query, making it easier to retrieve specific data from the database.</p> <p>It uses the <code>InspectionMixin</code> class functionality.</p> <p>Info</p> <p>This mixin is intended to extend the functionality of the <code>ActiveRecordMixin</code> on which the examples below are based. It is not intended to be used on its own.</p> <p>Table of Contents</p> <ul> <li>SmartQueryMixin</li> <li>Core Features<ul> <li>Smart Queries</li> <li>Filtering</li> <li>Sorting</li> <li>Eager Loading</li> </ul> </li> <li>API Reference<ul> <li>filter_expr</li> <li>order_expr</li> <li>eager_expr</li> </ul> </li> </ul>"},{"location":"pages/smart_query_mixin/#core-features","title":"Core Features","text":""},{"location":"pages/smart_query_mixin/#smart-queries","title":"Smart Queries","text":"<p>Smart queries allow you to filter, sort, and eager load data in a single query.</p> <pre><code>users = await User.smart_query(\n    criterion=(User.age &gt;= 18,),\n    filters={'name__like': '%Bob%'},\n    sort_columns=(User.username,),\n    sort_attrs=['-created_at'],\n    schema={User.posts: 'joined'}\n).all()\n</code></pre>"},{"location":"pages/smart_query_mixin/#filtering","title":"Filtering","text":"<p>You can filter data using native SQLAlchemy filter expressions.</p> <pre><code>users = await User.smart_query(\n    criterion=(User.age &gt;= 18,)\n).all()\n</code></pre> <p>Also, you can filter data using Django-like filter expressions.</p> <pre><code>users = await User.smart_query(\n    filters={'name__like': '%Bob%'}\n).all()\n</code></pre>"},{"location":"pages/smart_query_mixin/#sorting","title":"Sorting","text":"<p>You can sort data using native SQLAlchemy sort expressions with the <code>sort_columns</code> parameter.</p> <pre><code>users = await User.smart_query(\n    sort_columns=(User.username,)\n).all()\n</code></pre> <p>Also, you can sort data using Django-like sort expressions with the <code>sort_attrs</code> parameter.</p> <pre><code>users = await User.smart_query(\n    sort_attrs=['-created_at']\n).all()\n</code></pre>"},{"location":"pages/smart_query_mixin/#eager-loading","title":"Eager Loading","text":"<p>You can eager load relationships using various loading strategies with the <code>schema</code> parameter.</p> <pre><code>users = await User.smart_query(\n    schema={User.posts: 'joined'}\n).all()\n</code></pre>"},{"location":"pages/smart_query_mixin/#api-reference","title":"API Reference","text":"<p>The <code>SmartQueryMixin</code> class provides three low-level methods for building filter, sort and eager load expressions:</p> <ul> <li><code>filter_expr</code>: Builds filter expressions.</li> <li><code>order_expr</code>: Builds order expressions.</li> <li><code>eager_expr</code>: Builds eager load expressions.</li> </ul> <p>Warning</p> <p>All relations used in filtering/sorting should be explicitly set, not just being a <code>backref</code>. This is because <code>sqlactive</code> does not know the relation direction and cannot infer it. So, when defining a relationship like:</p> <pre><code>class User(BaseModel):\n    # ...\n    posts: Mapped[list['Post']] = relationship(back_populates='user')\n</code></pre> <p>It is required to define the reverse relationship:</p> <pre><code>class Post(BaseModel):\n    # ...\n    user: Mapped['User'] = relationship(back_populates='posts')\n</code></pre>"},{"location":"pages/smart_query_mixin/#filter_expr","title":"filter_expr","text":"<pre><code>def filter_expr(**filters: object)\n</code></pre> <p>Takes keyword arguments like <pre><code>{'age_from': 5, 'subject_ids__in': [1,2]}\n</code></pre> and returns list of expressions like <pre><code>[Product.age_from == 5, Product.subject_ids.in_([1,2])]\n</code></pre></p> <p>Info</p> <p>When using alias, for example:</p> <pre><code>alias = aliased(Product) # table name will be `product_1`\n</code></pre> <p>the query cannot be executed like</p> <pre><code>db.query(alias).filter(*Product.filter_expr(age_from=5))\n</code></pre> <p>because it will be compiled to</p> <pre><code>SELECT * FROM product_1 WHERE product.age_from=5\n</code></pre> <p>which is wrong. The select is made from <code>product_1</code> but filter is based on <code>product</code>. Such filter will not work. A correct way to execute such query is</p> <pre><code>SELECT * FROM product_1 WHERE product_1.age_from=5\n</code></pre> <p>For such case, <code>filter_expr</code> can be called ON ALIAS:</p> <pre><code>alias = aliased(Product)\ndb.query(alias).filter(*alias.filter_expr(age_from=5))\n</code></pre> <p>Parameters:</p> <ul> <li><code>filters</code>: Django-style filters.</li> </ul> <p>Returns:</p> <ul> <li><code>list[sqlalchemy.sql.elements.BinaryExpression]</code>: List of filter expressions.</li> </ul> <p>Raises:</p> <ul> <li><code>KeyError</code>:<ul> <li>If operator is not found in <code>_operators</code>.</li> <li>If attribute is not found in <code>filterable_attributes</code> property.</li> </ul> </li> </ul> <p>Example:</p> <pre><code>db.query(Product).filter(\n    *Product.filter_expr(age_from=5, subject_ids__in=[1, 2]))\n# will compile to WHERE age_from = 5 AND subject_ids IN [1, 2]\n\nfilters = {'age_from': 5, 'subject_ids__in': [1,2]}\ndb.query(Product).filter(*Product.filter_expr(**filters))\n# will compile to WHERE age_from = 5 AND subject_ids IN [1, 2]\n</code></pre>"},{"location":"pages/smart_query_mixin/#order_expr","title":"order_expr","text":"<pre><code>def order_expr(*columns: str)\n</code></pre> <p>Takes list of columns to order by like <pre><code>['-first_name', 'phone']\n</code></pre> and returns list of expressions like <pre><code>[desc(User.first_name), asc(User.phone)]\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>columns</code>: Django-style columns.</li> </ul> <p>Returns:</p> <ul> <li><code>list[sqlalchemy.sql.elements.UnaryExpression]</code>: List of sort expressions.</li> </ul> <p>Raises:</p> <ul> <li><code>KeyError</code>: If attribute is not sortable.</li> </ul> <p>Example:</p> <pre><code>db.query(User).order_by(*User.order_expr('-first_name'))\n# will compile to ORDER BY user.first_name DESC\n\ncolumns = ['-first_name', 'phone']\ndb.query(User).order_by(*User.order_expr(*columns))\n# will compile to ORDER BY user.first_name DESC, user.phone ASC\n</code></pre>"},{"location":"pages/smart_query_mixin/#eager_expr","title":"eager_expr","text":"<pre><code>def eager_expr(\n    schema: dict[InstrumentedAttribute, str | tuple[str, dict[InstrumentedAttribute, Any]] | dict]\n)\n</code></pre> <p>Takes schema like <pre><code>schema = {\n    Post.user: JOINED,  # joinedload user\n    Post.comments: (SUBQUERY, {  # load comments in separate query\n        Comment.user: JOINED  # but, in this separate query, join user\n    })\n}\n</code></pre> and returns eager loading expressions like <pre><code>[joinedload(Post.user), subqueryload(Post.comments).options(joinedload(Comment.user))]\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>schema</code>: Eager loading schema.</li> </ul> <p>Returns:</p> <ul> <li><code>list[sqlalchemy.orm.strategy_options._AbstractLoad]</code>: List of eager loading expressions.</li> </ul> <p>Example:</p> <pre><code>schema = {\n    User.posts: JOINED,\n    User.comments: (SUBQUERY, {Comment.post: SELECT_IN}),\n}\nusers = await User.options(*User.eager_expr(schema)).unique_all()\n</code></pre>"},{"location":"pages/timestamp_mixin/","title":"TimestampMixin","text":"<p>The <code>TimestampMixin</code> class provides automatic timestamp functionality for SQLAlchemy models.</p>"},{"location":"pages/timestamp_mixin/#customization","title":"Customization","text":""},{"location":"pages/timestamp_mixin/#columns","title":"Columns","text":"<p>You can customize the timestamp columns by setting the <code>__created_at_name__</code> and <code>__updated_at_name__</code> class attributes:</p> <pre><code>class MyModel(TimestampMixin):\n    __created_at_name__ = 'created_at'\n    __updated_at_name__ = 'updated_at'\n</code></pre>"},{"location":"pages/timestamp_mixin/#datetime-function","title":"Datetime function","text":"<p>You can customize the datetime function by setting the <code>__datetime_func__</code> class attribute:</p> <pre><code>from sqlalchemy.sql import func\n\nclass MyModel(TimestampMixin):\n    __datetime_func__ = func.current_timestamp()\n</code></pre>"},{"location":"pages/active_record_mixin/api_reference/","title":"API Reference","text":"<p>This is the API reference for the <code>ActiveRecordMixin</code> class.</p> <p>Table of Contents</p> <ul> <li>API Reference</li> <li>Instance Methods<ul> <li>fill</li> <li>save</li> <li>update</li> <li>edit</li> <li>delete</li> <li>remove</li> </ul> </li> <li>Class Methods<ul> <li>create</li> <li>insert</li> <li>add</li> <li>save_all</li> <li>create_all</li> <li>update_all</li> <li>delete_all</li> <li>destroy</li> <li>get</li> <li>get_or_fail</li> <li>options</li> <li>filter</li> <li>where</li> <li>find</li> <li>find_one</li> <li>find_one_or_none</li> <li>find_all</li> <li>find_first</li> <li>find_unique</li> <li>find_unique_all</li> <li>find_unique_first</li> <li>find_unique_one</li> <li>find_unique_one_or_none</li> <li>order_by</li> <li>sort</li> <li>offset</li> <li>skip</li> <li>limit</li> <li>take</li> <li>join</li> <li>with_subquery</li> <li>with_schema</li> <li>scalars</li> <li>first</li> <li>one</li> <li>one_or_none</li> <li>fetch_one</li> <li>fetch_one_or_none</li> <li>all</li> <li>fetch_all</li> <li>to_list</li> <li>unique</li> <li>unique_all</li> <li>unique_first</li> <li>unique_one</li> <li>unique_one_or_none</li> <li>smart_query</li> </ul> </li> </ul>"},{"location":"pages/active_record_mixin/api_reference/#instance-methods","title":"Instance Methods","text":""},{"location":"pages/active_record_mixin/api_reference/#fill","title":"fill","text":"<pre><code>def fill(**kwargs)\n</code></pre> <p>Fills the object with values from <code>kwargs</code> without saving to the database.</p> <p>Parameters:</p> <ul> <li><code>kwargs</code>: Key-value pairs of attributes to set.</li> </ul> <p>Returns:</p> <ul> <li><code>Self</code>: The instance itself for method chaining.</li> </ul> <p>Raises:</p> <ul> <li><code>KeyError</code>: If attribute doesn't exist.</li> </ul> <p>Example:</p> <pre><code>user.fill(name='Bob', age=30)\n</code></pre>"},{"location":"pages/active_record_mixin/api_reference/#save","title":"save","text":"<pre><code>async def save()\n</code></pre> <p>Saves the current row to the database.</p> <p>Returns:</p> <ul> <li><code>Self</code>: The saved instance for method chaining.</li> </ul> <p>Raises: Any database errors are caught and will trigger a rollback.</p> <p>Example:</p> <pre><code>user = User(name='Bob')\nawait user.save()\n</code></pre>"},{"location":"pages/active_record_mixin/api_reference/#update","title":"update","text":"<pre><code>async def update(**kwargs)\n</code></pre> <p>Updates the current row with the provided values.</p> <p>Parameters:</p> <ul> <li><code>kwargs</code>: Key-value pairs of attributes to update.</li> </ul> <p>Returns:</p> <ul> <li><code>Self</code>: The updated instance for method chaining.</li> </ul> <p>Raises: Any database errors are caught and will trigger a rollback.</p> <p>Example:</p> <pre><code>await user.update(name='Bob2', age=31)\n</code></pre>"},{"location":"pages/active_record_mixin/api_reference/#edit","title":"edit","text":"<pre><code>async def edit(**kwargs)\n</code></pre> <p>Synonym for <code>update()</code>.</p>"},{"location":"pages/active_record_mixin/api_reference/#delete","title":"delete","text":"<pre><code>async def delete()\n</code></pre> <p>Deletes the current row from the database.</p> <p>Raises: Any database errors are caught and will trigger a rollback.</p> <p>Example:</p> <pre><code>await user.delete()\n</code></pre>"},{"location":"pages/active_record_mixin/api_reference/#remove","title":"remove","text":"<pre><code>async def remove()\n</code></pre> <p>Synonym for <code>delete()</code>.</p>"},{"location":"pages/active_record_mixin/api_reference/#class-methods","title":"Class Methods","text":""},{"location":"pages/active_record_mixin/api_reference/#create","title":"create","text":"<pre><code>async def create(**kwargs)\n</code></pre> <p>Creates a new row with the provided values.</p> <p>Parameters:</p> <ul> <li><code>kwargs</code>: Key-value pairs for the new instance.</li> </ul> <p>Returns:</p> <ul> <li><code>Self</code>: The created instance for method chaining.</li> </ul> <p>Raises: Any database errors are caught and will trigger a rollback.</p> <p>Example:</p> <pre><code>user = await User.create(name='Bob', age=30)\n</code></pre>"},{"location":"pages/active_record_mixin/api_reference/#insert","title":"insert","text":"<pre><code>async def insert(**kwargs)\n</code></pre> <p>Synonym for <code>create()</code>.</p>"},{"location":"pages/active_record_mixin/api_reference/#add","title":"add","text":"<pre><code>async def add(**kwargs)\n</code></pre> <p>Synonym for <code>create()</code>.</p>"},{"location":"pages/active_record_mixin/api_reference/#save_all","title":"save_all","text":"<pre><code>async def save_all(rows: Sequence[Self], refresh: bool = False)\n</code></pre> <p>Saves multiple rows in a single transaction.</p> <p>Parameters:</p> <ul> <li><code>rows</code>: Sequence of model instances to save.</li> <li><code>refresh</code>: Whether to refresh the instances after saving (default: <code>False</code>).</li> </ul> <p>Raises: Any database errors are caught and will trigger a rollback.</p> <p>Example:</p> <pre><code>users = [User(name='Bob'), User(name='Alice')]\nawait User.save_all(users)\n</code></pre>"},{"location":"pages/active_record_mixin/api_reference/#create_all","title":"create_all","text":"<pre><code>async def create_all(rows: Sequence[Self], refresh: bool = False)\n</code></pre> <p>Synonym for <code>save_all()</code> when creating new rows.</p>"},{"location":"pages/active_record_mixin/api_reference/#update_all","title":"update_all","text":"<pre><code>async def update_all(rows: Sequence[Self], refresh: bool = False)\n</code></pre> <p>Synonym for <code>save_all()</code> when updating existing rows.</p>"},{"location":"pages/active_record_mixin/api_reference/#delete_all","title":"delete_all","text":"<pre><code>async def delete_all(rows: Sequence[Self])\n</code></pre> <p>Deletes multiple rows in a single transaction.</p> <p>Parameters:</p> <ul> <li><code>rows</code>: Sequence of model instances to delete.</li> </ul> <p>Raises: Any database errors are caught and will trigger a rollback.</p> <p>Example:</p> <pre><code>users = await User.where(age__lt=18).all()\nawait User.delete_all(users)\n</code></pre>"},{"location":"pages/active_record_mixin/api_reference/#destroy","title":"destroy","text":"<pre><code>async def destroy(*ids: object)\n</code></pre> <p>Deletes multiple rows by their primary keys.</p> <p>Parameters:</p> <ul> <li><code>ids</code>: Primary key values of rows to delete.</li> </ul> <p>Raises: Any database errors are caught and will trigger a rollback.</p> <p>Example:</p> <pre><code>await User.destroy(1, 2, 3)  # Deletes users with IDs 1, 2, and 3\n</code></pre>"},{"location":"pages/active_record_mixin/api_reference/#get","title":"get","text":"<pre><code>async def get(pk: object)\n</code></pre> <p>Fetches a row by primary key.</p> <p>Parameters:</p> <ul> <li><code>pk</code>: Primary key value.</li> </ul> <p>Returns:</p> <ul> <li><code>Self | None</code>: Instance for method chaining or <code>None</code> if not found.</li> </ul> <p>Raises:</p> <ul> <li><code>MultipleResultsFound</code>: If multiple rows match.</li> </ul> <p>Example:</p> <pre><code>user = await User.get(1)\n</code></pre>"},{"location":"pages/active_record_mixin/api_reference/#get_or_fail","title":"get_or_fail","text":"<pre><code>async def get_or_fail(pk: object)\n</code></pre> <p>Fetches a row by primary key or raises an exception if not found.</p> <p>Parameters:</p> <ul> <li><code>pk</code>: Primary key value.</li> </ul> <p>Returns:</p> <ul> <li><code>Self</code>: Instance for method chaining.</li> </ul> <p>Raises:</p> <ul> <li><code>NoResultFound</code>: If no row is found.</li> <li><code>MultipleResultsFound</code>: If multiple rows match.</li> </ul> <p>Example:</p> <pre><code>user = await User.get_or_fail(1)  # Raises if not found\n</code></pre>"},{"location":"pages/active_record_mixin/api_reference/#options","title":"options","text":"<pre><code>def options(*args: ExecutableOption)\n</code></pre> <p>Creates a query and applies the given list of mapper options.</p> <p>Warning</p> <p>Quoting from SQLAlchemy docs:</p> <pre><code>When including `joinedload()` in reference to a one-to-many or\nmany-to-many collection, the `Result.unique()` method must be\napplied to the returned result, which will make the incoming rows\nunique by primary key that otherwise are multiplied out by the join.\nThe ORM will raise an error if this is not present.\n\nThis is not automatic in modern SQLAlchemy, as it changes the behavior\nof the result set to return fewer ORM objects than the statement would\nnormally return in terms of number of rows. Therefore SQLAlchemy keeps\nthe use of Result.unique() explicit, so there is no ambiguity that the\nreturned objects are made unique on primary key.\n</code></pre> <p>To learn more about options, see <code>sqlalchemy.orm.Query.options</code> docs.</p> <p>Parameters:</p> <ul> <li><code>args</code>: Mapper options.</li> </ul> <p>Returns:</p> <ul> <li><code>AsyncQuery</code>: Async query instance for chaining.</li> </ul> <p>Example:</p> <pre><code>users = await User.options(joinedload(User.posts)).unique_all()\n\nuser = await User.options(joinedload(User.posts)).first()\n\nusers = await User.options(subqueryload(User.posts)).all()\n</code></pre>"},{"location":"pages/active_record_mixin/api_reference/#filter","title":"filter","text":"<pre><code>def filter(*criterion: _ColumnExpressionArgument[bool], **filters: Any)\n</code></pre> <p>Creates a filtered query using SQLAlchemy or Django-style filters.</p> <p>Parameters:</p> <ul> <li><code>criterion</code>: SQLAlchemy style filter expressions.</li> <li><code>filters</code>: Django-style filters.</li> </ul> <p>Returns:</p> <ul> <li><code>AsyncQuery</code>: Async query instance for chaining.</li> </ul> <p>Example:</p> <pre><code># SQLAlchemy style\nusers = await User.filter(User.age &gt;= 18).all()\n\n# Django style\nusers = await User.filter(age__gte=18).all()\n\n# Mixed\nusers = await User.filter(User.age &gt;= 18, name__like='%Bob%').all()\n</code></pre>"},{"location":"pages/active_record_mixin/api_reference/#where","title":"where","text":"<pre><code>def where(*criterion: _ColumnExpressionArgument[bool], **filters: Any)\n</code></pre> <p>Synonym for <code>filter()</code>.</p>"},{"location":"pages/active_record_mixin/api_reference/#find","title":"find","text":"<pre><code>def find(*criterion: _ColumnExpressionArgument[bool], **filters: Any)\n</code></pre> <p>Synonym for <code>filter()</code>.</p>"},{"location":"pages/active_record_mixin/api_reference/#find_one","title":"find_one","text":"<pre><code>async def find_one(*criterion: _ColumnExpressionArgument[bool], **filters: Any)\n</code></pre> <p>Finds a single row matching the criteria.</p> <p>This is same as calling <code>await cls.find(*criterion, **filters).one()</code>.</p> <p>Returns:</p> <ul> <li><code>Self</code>: Instance for method chaining.</li> </ul> <p>Raises:</p> <ul> <li><code>NoResultFound</code>: If no row is found.</li> <li><code>MultipleResultsFound</code>: If multiple rows match.</li> </ul> <p>Example:</p> <pre><code>user = await User.find_one(name='Bob')  # Raises if not found\n</code></pre>"},{"location":"pages/active_record_mixin/api_reference/#find_one_or_none","title":"find_one_or_none","text":"<pre><code>async def find_one_or_none(*criterion: _ColumnExpressionArgument[bool], **filters: Any)\n</code></pre> <p>Finds a single row matching the criteria or <code>None</code>.</p> <p>This is same as calling <code>await cls.find(*criterion, **filters).one_or_none()</code>.</p> <p>Returns:</p> <ul> <li><code>Self | None</code>: Instance for method chaining or <code>None</code>.</li> </ul> <p>Raises:</p> <ul> <li><code>MultipleResultsFound</code>: If multiple rows match.</li> </ul> <p>Example:</p> <pre><code>user = await User.find_one_or_none(name='Bob')  # Returns None if not found\n</code></pre>"},{"location":"pages/active_record_mixin/api_reference/#find_all","title":"find_all","text":"<pre><code>async def find_all(*criterion: _ColumnExpressionArgument[bool], **filters: Any)\n</code></pre> <p>Finds all rows matching the criteria.</p> <p>This is same as calling <code>await cls.find(*criterion, **filters).all()</code>.</p> <p>Returns:</p> <ul> <li><code>list[Self]</code>: List of instances for method chaining.</li> </ul> <p>Example:</p> <pre><code>users = await User.find_all(age__gte=18)\n</code></pre>"},{"location":"pages/active_record_mixin/api_reference/#find_first","title":"find_first","text":"<pre><code>async def find_first(*criterion: _ColumnExpressionArgument[bool], **filters: Any)\n</code></pre> <p>Finds a single row matching the criteria or <code>None</code>.</p> <p>This is same as calling <code>await cls.find(*criterion, **filters).first()</code>.</p> <p>Returns:</p> <ul> <li><code>Self | None</code>: Instance for method chaining or <code>None</code>.</li> </ul> <p>Example:</p> <pre><code>user = await User.find_first(name='Bob')\n</code></pre>"},{"location":"pages/active_record_mixin/api_reference/#find_unique","title":"find_unique","text":"<pre><code>async def find_unique(*criterion: _ColumnExpressionArgument[bool], **filters: Any)\n</code></pre> <p>Finds all unique rows matching the criteria and returns an <code>ScalarResult</code> object with them.</p> <p>This is same as calling <code>await cls.find(*criterion, **filters).unique()</code>.</p> <p>Returns:</p> <ul> <li><code>sqlalchemy.engine.ScalarResult</code>: Scalars.</li> </ul> <p>Example:</p> <pre><code>users_scalars = await User.find_unique(name__like='%John%')\nusers = users_scalars.all()\n</code></pre>"},{"location":"pages/active_record_mixin/api_reference/#find_unique_all","title":"find_unique_all","text":"<pre><code>async def find_unique_all(*criterion: _ColumnExpressionArgument[bool], **filters: Any)\n</code></pre> <p>Finds all unique rows matching the criteria and returns a list.</p> <p>This is same as calling <code>await cls.find(*criterion, **filters).unique_all()</code>.</p> <p>Returns:</p> <ul> <li><code>list[Self]</code>: List of instances.</li> </ul> <p>Example:</p> <pre><code>users = await User.find_unique_all(name__like='%John%')\n</code></pre>"},{"location":"pages/active_record_mixin/api_reference/#find_unique_first","title":"find_unique_first","text":"<pre><code>async def find_unique_first(*criterion: _ColumnExpressionArgument[bool], **filters: Any)\n</code></pre> <p>Finds a single unique row matching the criteria or <code>None</code>.</p> <p>This is same as calling <code>await cls.find(*criterion, **filters).unique_first()</code>.</p> <p>Returns:</p> <ul> <li><code>Self | None</code>: Instance for method chaining or <code>None</code>.</li> </ul> <p>Example:</p> <pre><code>user = await User.find_unique_first(name__like='%John%', age=30)\n</code></pre>"},{"location":"pages/active_record_mixin/api_reference/#find_unique_one","title":"find_unique_one","text":"<pre><code>async def find_unique_one(*criterion: _ColumnExpressionArgument[bool], **filters: Any)\n</code></pre> <p>Finds a single unique row matching the criteria.</p> <p>This is same as calling <code>await cls.find(*criterion, **filters).unique_one()</code>.</p> <p>Returns:</p> <ul> <li><code>Self</code>: Instance for method chaining.</li> </ul> <p>Raises:</p> <ul> <li><code>NoResultFound</code>: If no row is found.</li> <li><code>MultipleResultsFound</code>: If multiple rows match.</li> </ul> <p>Example:</p> <pre><code>user = await User.find_unique_one(name__like='%John%', age=30)\n</code></pre>"},{"location":"pages/active_record_mixin/api_reference/#find_unique_one_or_none","title":"find_unique_one_or_none","text":"<pre><code>async def find_unique_one_or_none(*criterion: _ColumnExpressionArgument[bool], **filters: Any)\n</code></pre> <p>Finds a single unique row matching the criteria or <code>None</code>.</p> <p>This is same as calling <code>await cls.find(*criterion, **filters).unique_one_or_none()</code>.</p> <p>Returns:</p> <ul> <li><code>Self | None</code>: Instance for method chaining or <code>None</code>.</li> </ul> <p>Raises:</p> <ul> <li><code>MultipleResultsFound</code>: If multiple rows match.</li> </ul> <p>Example:</p> <pre><code>user = await User.find_unique_one_or_none(name__like='%John%', age=30)\n</code></pre>"},{"location":"pages/active_record_mixin/api_reference/#order_by","title":"order_by","text":"<pre><code>def order_by(*columns: _ColumnExpressionOrStrLabelArgument[Any])\n</code></pre> <p>Creates a query with ORDER BY clause.</p> <p>Parameters:</p> <ul> <li><code>columns</code>: Column names or SQLAlchemy column expressions.</li> </ul> <p>Returns:</p> <ul> <li><code>AsyncQuery</code>: Async query instance for chaining.</li> </ul> <p>Example:</p> <pre><code># String column names (Django style)\nusers = await User.order_by('-created_at', 'name').all()\n\n# SQLAlchemy expressions\nusers = await User.order_by(User.created_at.desc(), User.name).all()\n</code></pre>"},{"location":"pages/active_record_mixin/api_reference/#sort","title":"sort","text":"<pre><code>def sort(*columns: _ColumnExpressionOrStrLabelArgument[Any])\n</code></pre> <p>Synonym for <code>order_by()</code>.</p>"},{"location":"pages/active_record_mixin/api_reference/#offset","title":"offset","text":"<pre><code>def offset(offset: int)\n</code></pre> <p>Creates a query with OFFSET clause.</p> <p>Parameters:</p> <ul> <li><code>offset</code>: Number of rows to skip.</li> </ul> <p>Returns:</p> <ul> <li><code>AsyncQuery</code>: Async query instance for chaining.</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code>: If offset is negative.</li> </ul> <p>Example:</p> <pre><code>users = await User.offset(10).all()\n</code></pre>"},{"location":"pages/active_record_mixin/api_reference/#skip","title":"skip","text":"<pre><code>def skip(skip: int)\n</code></pre> <p>Synonym for <code>offset()</code>.</p>"},{"location":"pages/active_record_mixin/api_reference/#limit","title":"limit","text":"<pre><code>def limit(limit: int)\n</code></pre> <p>Creates a query with LIMIT clause.</p> <p>Parameters:</p> <ul> <li><code>limit</code>: Maximum number of rows to return.</li> </ul> <p>Returns:</p> <ul> <li><code>AsyncQuery</code>: Async query instance for chaining.</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code>: If limit is negative.</li> </ul> <p>Example:</p> <pre><code>users = await User.limit(5).all()\n</code></pre>"},{"location":"pages/active_record_mixin/api_reference/#take","title":"take","text":"<pre><code>def take(take: int)\n</code></pre> <p>Synonym for <code>limit()</code>.</p>"},{"location":"pages/active_record_mixin/api_reference/#join","title":"join","text":"<pre><code>def join(*paths: QueryableAttribute | tuple[QueryableAttribute, bool])\n</code></pre> <p>Creates a query with <code>LEFT OUTER JOIN</code> eager loading.</p> <p>When a tuple is passed, the second element must be boolean. If it is <code>True</code>, the join is <code>INNER JOIN</code>, otherwise <code>LEFT OUTER JOIN</code>.</p> <p>Parameters:</p> <ul> <li><code>paths</code>: Relationship attributes to join.</li> </ul> <p>Returns:</p> <ul> <li><code>AsyncQuery</code>: Async query instance for chaining.</li> </ul> <p>Example:</p> <pre><code>comments = await Comment.join(\n    Comment.user,\n    (Comment.post, True)  # True means INNER JOIN\n).all()\n</code></pre>"},{"location":"pages/active_record_mixin/api_reference/#with_subquery","title":"with_subquery","text":"<pre><code>def with_subquery(*paths: QueryableAttribute | tuple[QueryableAttribute, bool])\n</code></pre> <p>Creates a query with subquery or selectin loading.</p> <p>Emits a second <code>SELECT</code> statement (Subqueryload) for each relationship to be loaded, across all result objects at once.</p> <p>When a tuple is passed, the second element must be boolean. If it is <code>True</code>, the eager loading strategy is <code>SELECT IN</code> (Selectinload), otherwise <code>SELECT JOIN</code> (Subqueryload).</p> <p>Warning</p> <p>A query which makes use of <code>subqueryload()</code> in conjunction with a limiting modifier such as <code>Query.limit()</code> or <code>Query.offset()</code> should always include <code>Query.order_by()</code> against unique column(s) such as the primary key, so that the additional queries emitted by <code>subqueryload()</code> include the same ordering as used by the parent query. Without it, there is a chance that the inner query could return the wrong rows, as specified in SQLAlchemy docs.</p> <pre><code># incorrect, no ORDER BY\nUser.options(subqueryload(User.addresses)).first()\n# incorrect if User.name is not unique\nUser.options(subqueryload(User.addresses)).order_by(User.name).first()\n# correct\nUser.options(subqueryload(User.addresses)).order_by(\n    User.name, User.id\n).first()\n</code></pre> <p>Parameters:</p> <ul> <li><code>paths</code>: Relationship attributes to load.</li> </ul> <p>Returns:</p> <ul> <li><code>AsyncQuery</code>: Async query instance for chaining.</li> </ul> <p>Example:</p> <pre><code>users = await User.with_subquery(\n    User.posts,\n    (User.comments, True)  # True means selectin loading\n).all()\n</code></pre>"},{"location":"pages/active_record_mixin/api_reference/#with_schema","title":"with_schema","text":"<pre><code>def with_schema(\n    schema: dict[InstrumentedAttribute, str | tuple[str, dict[InstrumentedAttribute, Any]] | dict]\n)\n</code></pre> <p>Creates a query with complex eager loading schema.</p> <p>Useful for complex cases where you need to load nested relationships in separate queries.</p> <p>Parameters:</p> <ul> <li><code>schema</code>: Dictionary defining the loading strategy.</li> </ul> <p>Returns:</p> <ul> <li><code>AsyncQuery</code>: Async query instance for chaining.</li> </ul> <pre><code>from sqlactive import JOINED, SUBQUERY\nschema = {\n    User.posts: JOINED,\n    User.comments: (SUBQUERY, {\n        Comment.user: JOINED\n    })\n}\nusers = await User.with_schema(schema).all()\n</code></pre>"},{"location":"pages/active_record_mixin/api_reference/#scalars","title":"scalars","text":"<pre><code>async def scalars()\n</code></pre> <p>Returns a <code>sqlalchemy.engine.ScalarResult</code> object containing all rows.</p> <p>Returns:</p> <ul> <li><code>sqlalchemy.engine.ScalarResult</code>: Scalars.</li> </ul> <p>Example:</p> <pre><code>result = await User.scalars()\nusers = result.all()\n</code></pre>"},{"location":"pages/active_record_mixin/api_reference/#first","title":"first","text":"<pre><code>async def first()\n</code></pre> <p>Fetches the first row.</p> <p>Returns:</p> <ul> <li><code>Self | None</code>: Instance for method chaining or <code>None</code> if no matches.</li> </ul> <p>Example:</p> <pre><code>user = await User.first()\n</code></pre>"},{"location":"pages/active_record_mixin/api_reference/#one","title":"one","text":"<pre><code>async def one()\n</code></pre> <p>Fetches exactly one row.</p> <p>Returns:</p> <ul> <li><code>Self</code>: Instance for method chaining.</li> </ul> <p>Raises:</p> <ul> <li><code>NoResultFound</code>: If no row is found.</li> <li><code>MultipleResultsFound</code>: If multiple rows match.</li> </ul> <p>Example:</p> <pre><code>user = await User.one()  # Raises if not exactly one match\n</code></pre>"},{"location":"pages/active_record_mixin/api_reference/#one_or_none","title":"one_or_none","text":"<pre><code>async def one_or_none()\n</code></pre> <p>Fetches exactly one row or <code>None</code>.</p> <p>Returns:</p> <ul> <li><code>Self | None</code>: Instance for method chaining or <code>None</code>.</li> </ul> <p>Raises:</p> <ul> <li><code>MultipleResultsFound</code>: If multiple rows match.</li> </ul> <p>Example:</p> <pre><code>user = await User.one_or_none()\n</code></pre>"},{"location":"pages/active_record_mixin/api_reference/#fetch_one","title":"fetch_one","text":"<pre><code>async def fetch_one()\n</code></pre> <p>Synonym for <code>one()</code>.</p>"},{"location":"pages/active_record_mixin/api_reference/#fetch_one_or_none","title":"fetch_one_or_none","text":"<pre><code>async def fetch_one_or_none()\n</code></pre> <p>Synonym for <code>one_or_none()</code>.</p>"},{"location":"pages/active_record_mixin/api_reference/#all","title":"all","text":"<pre><code>async def all()\n</code></pre> <p>Fetches all rows.</p> <p>Returns:</p> <ul> <li><code>list[Self]</code>: List of instances.</li> </ul> <p>Example:</p> <pre><code>users = await User.all()\n</code></pre>"},{"location":"pages/active_record_mixin/api_reference/#fetch_all","title":"fetch_all","text":"<pre><code>async def fetch_all()\n</code></pre> <p>Synonym for <code>all()</code>.</p>"},{"location":"pages/active_record_mixin/api_reference/#to_list","title":"to_list","text":"<pre><code>async def to_list()\n</code></pre> <p>Synonym for <code>all()</code>.</p>"},{"location":"pages/active_record_mixin/api_reference/#unique","title":"unique","text":"<pre><code>async def unique()\n</code></pre> <p>Returns a <code>sqlalchemy.engine.ScalarResult</code> object containing all unique rows.</p> <p>Returns:</p> <ul> <li><code>sqlalchemy.engine.ScalarResult</code>: Scalars.</li> </ul> <p>Example:</p> <pre><code>result = await User.unique()\nusers = result.all()\n</code></pre>"},{"location":"pages/active_record_mixin/api_reference/#unique_all","title":"unique_all","text":"<pre><code>async def unique_all()\n</code></pre> <p>Fetches all unique rows.</p> <p>Returns:</p> <ul> <li><code>list[Self]</code>: List of instances.</li> </ul> <p>Example:</p> <pre><code>users = await User.unique_all()\n</code></pre>"},{"location":"pages/active_record_mixin/api_reference/#unique_first","title":"unique_first","text":"<pre><code>async def unique_first()\n</code></pre> <p>Fetches the first unique row.</p> <p>Returns:</p> <ul> <li><code>Self | None</code>: Instance for method chaining or <code>None</code>.</li> </ul> <p>Example:</p> <pre><code>user = await User.unique_first()\n</code></pre>"},{"location":"pages/active_record_mixin/api_reference/#unique_one","title":"unique_one","text":"<pre><code>async def unique_one()\n</code></pre> <p>Fetches exactly one unique row.</p> <p>Returns:</p> <ul> <li><code>Self</code>: Instance for method chaining.</li> </ul> <p>Raises:</p> <ul> <li><code>NoResultFound</code>: If no row is found.</li> <li><code>MultipleResultsFound</code>: If multiple rows match.</li> </ul> <p>Example:</p> <pre><code>user = await User.unique_one()\n</code></pre>"},{"location":"pages/active_record_mixin/api_reference/#unique_one_or_none","title":"unique_one_or_none","text":"<pre><code>async def unique_one_or_none()\n</code></pre> <p>Fetches exactly one unique row or <code>None</code>.</p> <p>Returns:</p> <ul> <li><code>Self | None</code>: Instance for method chaining or <code>None</code>.</li> </ul> <p>Raises:</p> <ul> <li><code>MultipleResultsFound</code>: If multiple rows match.</li> </ul> <p>Example:</p> <pre><code>user = await User.unique_one_or_none()\n</code></pre>"},{"location":"pages/active_record_mixin/api_reference/#smart_query","title":"smart_query","text":"<pre><code>def smart_query(\n    criterion: Sequence[_ColumnExpressionArgument[bool]] | None = None,\n    filters: dict[str, Any] | dict[OperatorType, Any] | list[dict[str, Any]] | list[dict[OperatorType, Any]] | None = None,\n    sort_columns: Sequence[_ColumnExpressionOrStrLabelArgument[Any]] | None = None,\n    sort_attrs: Sequence[str] | None = None,\n    schema: dict[InstrumentedAttribute, str | tuple[str, dict[InstrumentedAttribute, Any]] | dict] | None = None,\n)\n</code></pre> <p>Creates a query combining filtering, sorting, and eager loading.</p> <p>Parameters:</p> <ul> <li><code>criterion</code>: SQLAlchemy filter expressions.</li> <li><code>filters</code>: Django-style filters.</li> <li><code>sort_columns</code>: SQLAlchemy columns to sort by.</li> <li><code>sort_attrs</code>: String column names to sort by.</li> <li><code>schema</code>: Eager loading schema.</li> </ul> <p>Returns:</p> <ul> <li><code>AsyncQuery</code>: Async query instance for chaining.</li> </ul> <p>Example:</p> <pre><code>users = await User.smart_query(\n    criterion=(User.age &gt;= 18,),\n    filters={'name__like': '%Bob%'},\n    sort_columns=(User.username,),\n    sort_attrs=['-created_at'],\n    schema={User.posts: 'joined'}\n).all()\n</code></pre>"},{"location":"pages/active_record_mixin/async_query/","title":"AsyncQuery","text":"<p>This class is an Async wrapper for <code>sqlalchemy.sql.Select</code>.</p> <p>Table of Contents</p> <ul> <li>AsyncQuery</li> <li>Usage</li> <li>API Reference<ul> <li>options</li> <li>filter</li> <li>order_by</li> <li>sort</li> <li>offset</li> <li>skip</li> <li>limit</li> <li>take</li> <li>join</li> <li>with_subquery</li> <li>with_schema</li> <li>execute</li> <li>scalars</li> <li>first</li> <li>one</li> <li>one_or_none</li> <li>fetch_one</li> <li>fetch_one_or_none</li> <li>all</li> <li>fetch_all</li> <li>to_list</li> <li>unique</li> <li>unique_all</li> <li>unique_first</li> <li>unique_one</li> <li>unique_one_or_none</li> </ul> </li> <li>Access the Native Query Object</li> </ul>"},{"location":"pages/active_record_mixin/async_query/#usage","title":"Usage","text":"<p>The <code>AsyncQuery</code> class provides a set of helper methods for asynchronously executing the query.</p> <p>Example of usage:</p> <pre><code>    query = select(User)\n    async_query = AsyncQuery(query, User._session)\n    async_query = async_query.filter(name__like='%John%').sort('-created_at').limit(2)\n    users = await async_query.all()\n    &gt;&gt;&gt; users\n    # [&lt;User 1&gt;, &lt;User 2&gt;]\n</code></pre> <p>To get the <code>sqlalchemy.sql.Select</code> instance to use native SQLAlchemy methods use the <code>query</code> property:</p> <pre><code>    query = select(User)\n    async_query = AsyncQuery(query, User._session)\n    async_query.query\n    # &lt;sqlalchemy.sql.Select object at 0x7f7f7f7f7f7f7f7f&gt;\n</code></pre> <p>Warning</p> <p>If no session is provided, a <code>NoSessionError</code> will be raised when attempting to execute the query. You must either provide a session by passing it in this constructor or by calling the <code>set_session</code> method.</p> <p>In the constructor:</p> <pre><code>query = select(User)\nasync_query = AsyncQuery(query, User._session)\n</code></pre> <p>Calling the <code>set_session</code> method:</p> <pre><code>query = select(User)\nasync_query = AsyncQuery(query)\nasync_query.set_session(User._session)\n</code></pre>"},{"location":"pages/active_record_mixin/async_query/#api-reference","title":"API Reference","text":""},{"location":"pages/active_record_mixin/async_query/#options","title":"options","text":"<pre><code>def options(*args: ExecutableOption)\n</code></pre> <p>Applies the given list of mapper options.</p> <p>Warning</p> <p>Quoting from SQLAlchemy docs:</p> <pre><code>When including `joinedload()` in reference to a one-to-many or\nmany-to-many collection, the `Result.unique()` method must be\napplied to the returned result, which will make the incoming rows\nunique by primary key that otherwise are multiplied out by the join.\nThe ORM will raise an error if this is not present.\n\nThis is not automatic in modern SQLAlchemy, as it changes the behavior\nof the result set to return fewer ORM objects than the statement would\nnormally return in terms of number of rows. Therefore SQLAlchemy keeps\nthe use of Result.unique() explicit, so there is no ambiguity that the\nreturned objects are made unique on primary key.\n</code></pre> <p>To learn more about options, see <code>sqlalchemy.orm.Query.options</code> docs.</p> <p>Parameters:</p> <ul> <li><code>args</code>: Mapper options.</li> </ul> <p>Returns:</p> <ul> <li><code>AsyncQuery</code>: Async query instance for chaining.</li> </ul> <p>Example:</p> <pre><code>query = select(User)\nasync_query = AsyncQuery(query)\n\nusers = await async_query.options(joinedload(User.posts)).unique_all()\n\nuser = await async_query.options(joinedload(User.posts)).first()\n\nusers = await async_query.options(subqueryload(User.posts)).all()\n</code></pre>"},{"location":"pages/active_record_mixin/async_query/#filter","title":"filter","text":"<pre><code>def filter(*criterion: _ColumnExpressionArgument[bool], **filters: Any)\n</code></pre> <p>Filters the query.</p> <p>Creates the WHERE clause of the query.</p> <p>Parameters:</p> <ul> <li><code>criterion</code>: SQLAlchemy style filter expressions.</li> <li><code>filters</code>: Django-style filters.</li> </ul> <p>Returns:</p> <ul> <li><code>AsyncQuery</code>: Async query instance for chaining.</li> </ul> <p>Example:</p> <pre><code>query = select(User)\nasync_query = AsyncQuery(query)\n\n# SQLAlchemy style\nusers = await async_query.filter(User.age &gt;= 18).all()\n\n# Django style\nusers = await async_query.filter(age__gte=18).all()\n\n# Mixed\nusers = await async_query.filter(User.age &gt;= 18, name__like='%Bob%').all()\n</code></pre>"},{"location":"pages/active_record_mixin/async_query/#order_by","title":"order_by","text":"<pre><code>def order_by(*columns: _ColumnExpressionOrStrLabelArgument[Any])\n</code></pre> <p>Applies one or more ORDER BY criteria to the query.</p> <p>Parameters:</p> <ul> <li><code>columns</code>: Column names or SQLAlchemy column expressions.</li> </ul> <p>Returns:</p> <ul> <li><code>AsyncQuery</code>: Async query instance for chaining.</li> </ul> <p>Example:</p> <pre><code>query = select(User)\nasync_query = AsyncQuery(query)\n\n# String column names (Django style)\nusers = await async_query.order_by('-created_at', 'name').all()\n\n# SQLAlchemy expressions\nusers = await async_query.order_by(User.created_at.desc(), User.name).all()\n</code></pre>"},{"location":"pages/active_record_mixin/async_query/#sort","title":"sort","text":"<pre><code>def sort(*columns: _ColumnExpressionOrStrLabelArgument[Any])\n</code></pre> <p>Synonym for <code>order_by()</code>.</p>"},{"location":"pages/active_record_mixin/async_query/#offset","title":"offset","text":"<pre><code>def offset(offset: int)\n</code></pre> <p>Applies an OFFSET clause to the query.</p> <p>Parameters:</p> <ul> <li><code>offset</code>: Number of rows to skip.</li> </ul> <p>Returns:</p> <ul> <li><code>AsyncQuery</code>: Async query instance for chaining.</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code>: If offset is negative.</li> </ul> <p>Example:</p> <pre><code>query = select(User)\nasync_query = AsyncQuery(query)\n\nusers = await async_query.offset(10).all()\n</code></pre>"},{"location":"pages/active_record_mixin/async_query/#skip","title":"skip","text":"<pre><code>def skip(skip: int)\n</code></pre> <p>Synonym for <code>offset()</code>.</p>"},{"location":"pages/active_record_mixin/async_query/#limit","title":"limit","text":"<pre><code>def limit(limit: int)\n</code></pre> <p>Applies a LIMIT clause to the query.</p> <p>Parameters:</p> <ul> <li><code>limit</code>: Maximum number of rows to return.</li> </ul> <p>Returns:</p> <ul> <li><code>AsyncQuery</code>: Async query instance for chaining.</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code>: If limit is negative.</li> </ul> <p>Example:</p> <pre><code>query = select(User)\nasync_query = AsyncQuery(query)\n\nusers = await async_query.limit(5).all()\n</code></pre>"},{"location":"pages/active_record_mixin/async_query/#take","title":"take","text":"<pre><code>def take(take: int)\n</code></pre> <p>Synonym for <code>limit()</code>.</p>"},{"location":"pages/active_record_mixin/async_query/#join","title":"join","text":"<pre><code>def join(\n    *paths: QueryableAttribute | tuple[QueryableAttribute, bool],\n    model: type[_T] | None = None\n)\n</code></pre> <p>Joined eager loading using LEFT OUTER JOIN.</p> <p>When a tuple is passed, the second element must be boolean. If it is <code>True</code>, the join is <code>INNER JOIN</code>, otherwise <code>LEFT OUTER JOIN</code>.</p> <p>Parameters:</p> <ul> <li><code>paths</code>: Relationship attributes to join.</li> <li><code>model</code>: If given, checks that each path belongs to this model.</li> </ul> <p>Returns:</p> <ul> <li><code>AsyncQuery</code>: Async query instance for chaining.</li> </ul> <p>Example:</p> <pre><code>query = select(comments)\nasync_query = AsyncQuery(query)\n\ncomments = await async_query.join(\n    Comment.user,\n    (Comment.post, True),  # True means INNER JOIN\n    model=Comment   # Checks that Comment.user and Comment.post belongs to Comment\n).all()\n</code></pre> <pre><code>comments = await async_query.join(\n    Post.user,\n    model=Comment   # Post.user does not belong to Comment, so it will raise an error\n).all()\n</code></pre>"},{"location":"pages/active_record_mixin/async_query/#with_subquery","title":"with_subquery","text":"<pre><code>def with_subquery(\n    *paths: QueryableAttribute | tuple[QueryableAttribute, bool],\n    model: type[_T] | None = None\n)\n</code></pre> <p>Subqueryload or Selectinload eager loading.</p> <p>Emits a second <code>SELECT</code> statement (Subqueryload) for each relationship to be loaded, across all result objects at once.</p> <p>When a tuple is passed, the second element must be boolean. If it is <code>True</code>, the eager loading strategy is <code>SELECT IN</code> (Selectinload), otherwise <code>SELECT JOIN</code> (Subqueryload).</p> <p>Warning</p> <p>A query which makes use of <code>subqueryload()</code> in conjunction with a limiting modifier such as <code>Query.limit()</code> or <code>Query.offset()</code> should always include <code>Query.order_by()</code> against unique column(s) such as the primary key, so that the additional queries emitted by <code>subqueryload()</code> include the same ordering as used by the parent query. Without it, there is a chance that the inner query could return the wrong rows, as specified in SQLAlchemy docs.</p> <pre><code># incorrect, no ORDER BY\nUser.options(subqueryload(User.addresses)).first()\n# incorrect if User.name is not unique\nUser.options(subqueryload(User.addresses)).order_by(User.name).first()\n# correct\nUser.options(subqueryload(User.addresses)).order_by(\n    User.name, User.id\n).first()\n</code></pre> <p>Parameters:</p> <ul> <li><code>paths</code>: Relationship attributes to load.</li> <li><code>model</code>: If given, checks that each path belongs to this model.</li> </ul> <p>Returns:</p> <ul> <li><code>AsyncQuery</code>: Async query instance for chaining.</li> </ul> <p>Example:</p> <pre><code>query = select(User)\nasync_query = AsyncQuery(query)\n\nusers = await async_query.with_subquery(\n    User.posts,\n    (User.comments, True)  # True means selectin loading\n    model=User   # Checks that User.posts and User.comments belongs to User\n).all()\n</code></pre> <pre><code>users = await async_query.with_subquery(\n    Comment.posts,\n    model=User   # Comment.posts does not belong to User, so it will raise an error\n).all()\n</code></pre>"},{"location":"pages/active_record_mixin/async_query/#with_schema","title":"with_schema","text":"<pre><code>def with_schema(\n    schema: dict[InstrumentedAttribute, str | tuple[str, dict[InstrumentedAttribute, Any]] | dict]\n)\n</code></pre> <p>Joined, subqueryload and selectinload eager loading.</p> <p>Useful for complex cases where you need to load nested relationships in separate queries.</p> <p>Parameters:</p> <ul> <li><code>schema</code>: Dictionary defining the loading strategy.</li> </ul> <p>Returns:</p> <ul> <li><code>AsyncQuery</code>: Async query instance for chaining.</li> </ul> <pre><code>query = select(User)\nasync_query = AsyncQuery(query)\n\nfrom sqlactive import JOINED, SUBQUERY\nschema = {\n    User.posts: JOINED,\n    User.comments: (SUBQUERY, {\n        Comment.user: JOINED\n    })\n}\nusers = await async_query.with_schema(schema).all()\n</code></pre>"},{"location":"pages/active_record_mixin/async_query/#execute","title":"execute","text":"<pre><code>async def execute(self, params: _CoreAnyExecuteParams | None = None, **kwargs)\n</code></pre> <p>Executes the query.</p> <p>Parameters:</p> <ul> <li><code>params</code>: SQLAlchemy statement execution parameters.</li> </ul> <p>Returns:</p> <ul> <li><code>sqlalchemy.engine.Result[Any]</code>: Result of the query.</li> </ul> <p>Example:</p> <pre><code>query = select(User)\nasync_query = AsyncQuery(query)\n\nresult = await async_query.execute()\nusers = result.scalars().all()\n</code></pre>"},{"location":"pages/active_record_mixin/async_query/#scalars","title":"scalars","text":"<pre><code>async def scalars()\n</code></pre> <p>Returns a <code>sqlalchemy.engine.ScalarResult</code> object containing all rows.</p> <p>This is same as calling <code>(await self.execute()).scalars()</code>.</p> <p>Returns:</p> <ul> <li><code>sqlalchemy.engine.ScalarResult</code>: Scalars.</li> </ul> <p>Example:</p> <pre><code>query = select(User)\nasync_query = AsyncQuery(query)\n\nresult = await async_query.scalars()\nusers = result.all()\n</code></pre>"},{"location":"pages/active_record_mixin/async_query/#first","title":"first","text":"<pre><code>async def first()\n</code></pre> <p>Fetches the first row or <code>None</code> if no results are found.</p> <p>This is same as calling <code>(await self.scalars()).first()</code>.</p> <p>Returns:</p> <ul> <li><code>Self | None</code>: Instance for method chaining or <code>None</code> if no matches.</li> </ul> <p>Example:</p> <pre><code>query = select(User)\nasync_query = AsyncQuery(query)\n\nuser = await async_query.first()\n</code></pre>"},{"location":"pages/active_record_mixin/async_query/#one","title":"one","text":"<pre><code>async def one()\n</code></pre> <p>Fetches one row or raises an exception if no results are found.</p> <p>If multiple results are found, raises <code>MultipleResultsFound</code>.</p> <p>This is same as calling <code>(await self.scalars()).one()</code>.</p> <p>Returns:</p> <ul> <li><code>Self</code>: Instance for method chaining.</li> </ul> <p>Raises:</p> <ul> <li><code>NoResultFound</code>: If no row is found.</li> <li><code>MultipleResultsFound</code>: If multiple rows match.</li> </ul> <p>Example:</p> <pre><code>query = select(User)\nasync_query = AsyncQuery(query)\n\nuser = await async_query.one()  # Raises if not exactly one match\n</code></pre>"},{"location":"pages/active_record_mixin/async_query/#one_or_none","title":"one_or_none","text":"<pre><code>async def one_or_none()\n</code></pre> <p>Fetches one row or <code>None</code> if no results are found.</p> <p>If multiple results are found, raises <code>MultipleResultsFound</code>.</p> <p>This is same as calling <code>(await self.scalars()).one_or_none()</code>.</p> <p>Returns:</p> <ul> <li><code>Self | None</code>: Instance for method chaining or <code>None</code>.</li> </ul> <p>Raises:</p> <ul> <li><code>MultipleResultsFound</code>: If multiple rows match.</li> </ul> <p>Example:</p> <pre><code>query = select(User)\nasync_query = AsyncQuery(query)\n\nuser = await async_query.one_or_none()\n</code></pre>"},{"location":"pages/active_record_mixin/async_query/#fetch_one","title":"fetch_one","text":"<pre><code>async def fetch_one()\n</code></pre> <p>Synonym for <code>one()</code>.</p>"},{"location":"pages/active_record_mixin/async_query/#fetch_one_or_none","title":"fetch_one_or_none","text":"<pre><code>async def fetch_one_or_none()\n</code></pre> <p>Synonym for <code>one_or_none()</code>.</p>"},{"location":"pages/active_record_mixin/async_query/#all","title":"all","text":"<pre><code>async def all()\n</code></pre> <p>Fetches all rows.</p> <p>This is same as calling <code>(await self.scalars()).all()</code>.</p> <p>Returns:</p> <ul> <li><code>list[Self]</code>: List of instances.</li> </ul> <p>Example:</p> <pre><code>query = select(User)\nasync_query = AsyncQuery(query)\n\nusers = await async_query.all()\n</code></pre>"},{"location":"pages/active_record_mixin/async_query/#fetch_all","title":"fetch_all","text":"<pre><code>async def fetch_all()\n</code></pre> <p>Synonym for <code>all()</code>.</p>"},{"location":"pages/active_record_mixin/async_query/#to_list","title":"to_list","text":"<pre><code>async def to_list()\n</code></pre> <p>Synonym for <code>all()</code>.</p>"},{"location":"pages/active_record_mixin/async_query/#unique","title":"unique","text":"<pre><code>async def unique()\n</code></pre> <p>Returns a <code>sqlalchemy.engine.ScalarResult</code> object containing all unique rows.</p> <p>This is same as calling <code>(await self.scalars()).unique()</code>.</p> <p>Returns:</p> <ul> <li><code>sqlalchemy.engine.ScalarResult</code>: Scalars.</li> </ul> <p>Example:</p> <pre><code>query = select(User)\nasync_query = AsyncQuery(query)\n\nresult = await async_query.unique()\nusers = result.all()\n</code></pre>"},{"location":"pages/active_record_mixin/async_query/#unique_all","title":"unique_all","text":"<pre><code>async def unique_all()\n</code></pre> <p>Fetches all unique rows.</p> <p>This is same as calling <code>(await self.unique()).all()</code>.</p> <p>Returns:</p> <ul> <li><code>list[Self]</code>: List of instances.</li> </ul> <p>Example:</p> <pre><code>query = select(User)\nasync_query = AsyncQuery(query)\n\nusers = await async_query.unique_all()\n</code></pre>"},{"location":"pages/active_record_mixin/async_query/#unique_first","title":"unique_first","text":"<pre><code>async def unique_first()\n</code></pre> <p>Fetches the first unique row or <code>None</code> if no results are found.</p> <p>This is same as calling <code>(await self.unique()).first()</code>.</p> <p>Returns:</p> <ul> <li><code>Self | None</code>: Instance for method chaining or <code>None</code>.</li> </ul> <p>Example:</p> <pre><code>query = select(User)\nasync_query = AsyncQuery(query)\n\nuser = await async_query.unique_first()\n</code></pre>"},{"location":"pages/active_record_mixin/async_query/#unique_one","title":"unique_one","text":"<pre><code>async def unique_one()\n</code></pre> <p>Fetches one unique row or raises an exception if no results are found.</p> <p>If multiple results are found, raises <code>MultipleResultsFound</code>.</p> <p>This is same as calling <code>(await self.unique()).one()</code>.</p> <p>Returns:</p> <ul> <li><code>Self</code>: Instance for method chaining.</li> </ul> <p>Raises:</p> <ul> <li><code>NoResultFound</code>: If no row is found.</li> <li><code>MultipleResultsFound</code>: If multiple rows match.</li> </ul> <p>Example:</p> <pre><code>query = select(User)\nasync_query = AsyncQuery(query)\n\nuser = await async_query.unique_one()\n</code></pre>"},{"location":"pages/active_record_mixin/async_query/#unique_one_or_none","title":"unique_one_or_none","text":"<pre><code>async def unique_one_or_none()\n</code></pre> <p>Fetches one unique row or <code>None</code> if no results are found.</p> <p>If multiple results are found, raises <code>MultipleResultsFound</code>.</p> <p>This is same as calling <code>(await self.unique()).one_or_none()</code>.</p> <p>Returns:</p> <ul> <li><code>Self | None</code>: Instance for method chaining or <code>None</code>.</li> </ul> <p>Raises:</p> <ul> <li><code>MultipleResultsFound</code>: If multiple rows match.</li> </ul> <p>Example:</p> <pre><code>query = select(User)\nasync_query = AsyncQuery(query)\n\nuser = await async_query.unique_one_or_none()\n</code></pre>"},{"location":"pages/active_record_mixin/async_query/#access-the-native-query-object","title":"Access the Native Query Object","text":"<p>The native SQLAlchemy query object can be accessed via the <code>query</code> property.</p> <pre><code>query = select(User)\nasync_query = AsyncQuery(query)\nasync_query.query\n# &lt;sqlalchemy.sql.Select object at 0x7f7f7f7f7f7f7f7f&gt;\n\nasync_query.query = async_query.query.limit(10).order_by(User.age.desc())\nusers = await async_query.all()\n</code></pre>"},{"location":"pages/active_record_mixin/overview/","title":"ActiveRecord Mixin","text":"<p>The <code>ActiveRecordMixin</code> class provides ActiveRecord-style functionality for SQLAlchemy models, allowing for more intuitive and chainable database operations with async/await support.</p> <p>It uses the <code>SmartQueryMixin</code> class functionality.</p> <p>Check the API Reference for the full list of available methods.</p> <p>Table of Contents</p> <ul> <li>ActiveRecord Mixin</li> <li>Usage</li> <li>Core Features<ul> <li>Creation, Updating, and Deletion</li> <li>Creating Records</li> <li>Updating Records</li> <li>Deleting Records</li> <li>Querying</li> <li>Basic Queries</li> <li>Filtering</li> <li>Sorting and Pagination</li> <li>Eager Loading</li> <li>Join Loading</li> <li>Subquery Loading</li> <li>Complex Schema Loading</li> <li>Smart Queries</li> </ul> </li> <li>Important Notes</li> <li>Error Handling</li> <li>API Reference</li> </ul>"},{"location":"pages/active_record_mixin/overview/#usage","title":"Usage","text":"<p>To use the <code>ActiveRecordMixin</code>, create a base model class that inherits from it and set the <code>__abstract__</code> attribute to <code>True</code>:</p> <pre><code>from sqlalchemy import Mapped, mapped_column\nfrom sqlactive import ActiveRecordMixin\n\nclass BaseModel(ActiveRecordMixin):\n    __abstract__ = True\n\nclass User(BaseModel):\n    __tablename__ = 'users'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(String(100))\n</code></pre>"},{"location":"pages/active_record_mixin/overview/#core-features","title":"Core Features","text":""},{"location":"pages/active_record_mixin/overview/#creation-updating-and-deletion","title":"Creation, Updating, and Deletion","text":""},{"location":"pages/active_record_mixin/overview/#creating-records","title":"Creating Records","text":"<pre><code># Create a single record\nbob = await User.create(name='Bob')\n\n# Alternative creation methods\nbob = await User.insert(name='Bob')  # Synonym for create\nbob = await User.add(name='Bob')     # Synonym for create\n\n# Create multiple records\nusers = [User(name='Alice'), User(name='Bob')]\nawait User.create_all(users)\n</code></pre>"},{"location":"pages/active_record_mixin/overview/#updating-records","title":"Updating Records","text":"<pre><code># Update a single record\nawait user.update(name='Bob2')\nawait user.edit(name='Bob2')  # Synonym for update\n\n# Update multiple records\nusers = await User.where(age=25).all()\nfor user in users:\n    user.name = f\"{user.name} Jr.\"\nawait User.update_all(users)\n</code></pre>"},{"location":"pages/active_record_mixin/overview/#deleting-records","title":"Deleting Records","text":"<pre><code># Delete a single record\nawait user.delete()\nawait user.remove()  # Synonym for delete\n\n# Delete multiple records\nusers = await User.where(age=25).all()\nawait User.delete_all(users)\n\n# Delete by primary keys\nawait User.destroy(1, 2, 3)  # Deletes users with IDs 1, 2, and 3\n</code></pre>"},{"location":"pages/active_record_mixin/overview/#querying","title":"Querying","text":""},{"location":"pages/active_record_mixin/overview/#basic-queries","title":"Basic Queries","text":"<pre><code># Get all records\nusers = await User.all()\nusers = await User.fetch_all()  # Synonym for all\nusers = await User.to_list()    # Synonym for all\n\n# Get first record\nuser = await User.first()\n\n# Get one record\nuser = await User.one()                # Raises if no result found\nuser = await User.one_or_none()        # Returns None if no result found\nuser = await User.fetch_one()          # Synonym for one\nuser = await User.fetch_one_or_none()  # Synonym for one_or_none\n</code></pre>"},{"location":"pages/active_record_mixin/overview/#filtering","title":"Filtering","text":"<p>The mixin supports both Django-like syntax and SQLAlchemy syntax for filtering:</p> <pre><code># Django-like syntax\nusers = await User.filter(name__like='%John%').all()\nusers = await User.filter(name__like='%John%', age=30).all()\n\n# SQLAlchemy syntax\nusers = await User.filter(User.name == 'John Doe').all()\n\n# Mixed syntax\nusers = await User.filter(User.age == 30, name__like='%John%').all()\n\n# Alternative filter methods\nusers = await User.where(name__like='%John%').all()  # Synonym for filter\nusers = await User.find(name__like='%John%').all()   # Synonym for filter\n\n# Find one record\nuser = await User.find_one(name__like='%John%', age=30)  # Raises if not found\nuser = await User.find_one_or_none(name__like='%John%')  # Returns None if not found\n</code></pre>"},{"location":"pages/active_record_mixin/overview/#sorting-and-pagination","title":"Sorting and Pagination","text":"<pre><code>from sqlalchemy.sql import desc\n\n# Sorting (Django-like syntax)\nusers = await User.order_by('-created_at').all()  # Descending order\nusers = await User.sort('-created_at').all()      # Synonym for order_by\n\n# Sorting (SQLAlchemy syntax)\nusers = await User.order_by(User.created_at.desc()).all()\nusers = await User.sort(desc(User.created_at)).all()\n\n# Sorting (mixed syntax)\nusers = await User.order_by('-created_at', User.name.asc()).all()\nusers = await User.sort('-age', desc(User.name)).all()\n\n# Pagination\nusers = await User.offset(10).limit(5).all()  # Skip 10, take 5\nusers = await User.skip(10).take(5).all()     # Same as above\n</code></pre>"},{"location":"pages/active_record_mixin/overview/#eager-loading","title":"Eager Loading","text":""},{"location":"pages/active_record_mixin/overview/#join-loading","title":"Join Loading","text":"<pre><code># Left outer join\ncomment = await Comment.join(Comment.user, Comment.post).first()\n\ncomment = await Comment.join(\n    Comment.user,\n    (Comment.post, True)  # True means inner join\n).first()\n\ncomments = await Comment.join(Comment.user, Comment.post).unique_all()\n</code></pre>"},{"location":"pages/active_record_mixin/overview/#subquery-loading","title":"Subquery Loading","text":"<pre><code># Using subquery loading\nusers = await User.with_subquery(\n    User.posts,\n    (User.comments, True)  # True means selectinload\n).all()\n\n# With limiting and sorting (important for correct results)\nusers = await User.with_subquery(User.posts)\n    .limit(1)\n    .sort('id')  # important!\n    .all()\n</code></pre>"},{"location":"pages/active_record_mixin/overview/#complex-schema-loading","title":"Complex Schema Loading","text":"<pre><code>from sqlactive import JOINED, SUBQUERY\n\nschema = {\n    User.posts: JOINED,  # joinedload user\n    User.comments: (SUBQUERY, {  # load comments in separate query\n        Comment.user: JOINED  # but join user in this separate query\n    })\n}\n\nuser = await User.with_schema(schema).first()\n</code></pre>"},{"location":"pages/active_record_mixin/overview/#smart-queries","title":"Smart Queries","text":"<p>The <code>SmartQueryMixin</code> mixin provides a powerful smart query builder that combines filtering, sorting, and eager loading:</p> <pre><code># Complex query with multiple features\nusers = await User.smart_query(\n    criterion=(User.age &gt; 18,),\n    filters={'name__like': '%John%'},\n    sort_columns=(User.username,),\n    sort_attrs=['-created_at'],\n    schema={User.posts: JOINED}\n).all()\n</code></pre>"},{"location":"pages/active_record_mixin/overview/#important-notes","title":"Important Notes","text":"<ol> <li> <p>When using <code>subqueryload()</code> with limiting modifiers (<code>limit()</code>, <code>offset()</code>),    always include <code>order_by()</code> with unique columns (like primary key) to ensure    correct results.</p> </li> <li> <p>For joined eager loading with one-to-many or many-to-many relationships,    use the <code>unique()</code> method or unique-related methods (i.e. <code>unique_all()</code>) to    prevent duplicate rows:    <pre><code>users = await User.options(joinedload(User.posts)).unique_all()\n</code></pre></p> </li> </ol>"},{"location":"pages/active_record_mixin/overview/#error-handling","title":"Error Handling","text":"<p>The mixin includes proper error handling for common scenarios:</p> <ul> <li><code>NoResultFound</code>: Raised when a query expecting one result finds none.</li> <li><code>MultipleResultsFound</code>: Raised when a query expecting one result finds multiple.</li> <li><code>InvalidRequestError</code>: Raised for invalid query operations.</li> <li><code>KeyError</code>: Raised when trying to set non-existent attributes.</li> </ul> <p>All database operations are wrapped in try-except blocks with automatic rollback on failure.</p>"},{"location":"pages/active_record_mixin/overview/#api-reference","title":"API Reference","text":"<p>Check the API Reference for the full list of available methods.</p>"}]}